Table of Contents

[Glossary](#glossary)

[GitHub](#github)

[Analysis of the problem](#analysis-of-the-problem)

[Problem Identification](#problem-identification)

[Computational Approaches](#computational-approaches)

[Stakeholders](#stakeholders)

[Research](#research)

[Questionnaire](#questionnaire)

[Useful technical approaches](#useful-technical-approaches)

[Similar Programs](#similar-programs)

[Features](#features)

[Essential Features](#essential-features)

[Limitations](#limitations)

[Requirements](#requirements)

[Success Criteria](#success-criteria)

[Design](#design)

[Problem Decomposition](#problem-decomposition)

[Table](#table)

[Flowchart](#flowchart)

[Solutions](#solutions)

[Sorting Algorithms](#sorting-algorithms)

[Searching Algorithms](#searching-algorithms)

[Cube Algorithms](#cube-algorithms)

[Useability Features](#useability-features)

[Data and Variables](#data-and-variables)

[Validation](#validation)

[Iterative-Development Test Data](#iterative-development-test-data)

[Post-Development Test Data](#post-development-test-data)

[Test plan](#test-plan)

[Quiz template](#quiz-template)

[Implementation](#implementation)

[Prototype One](#prototype-one)

[Development](#development)

[Testing](#testing)

[Improvements](#improvements)

[Program Images](#program-images)

[Prototype 2](#prototype-2)

[Development](#development-1)

[Testing](#testing-1)

[Improvements](#improvements-1)

[Program Images](#program-images-1)

[Prototype 3](#prototype-3)

[Development](#development-2)

[Testing](#testing-2)

[Improvements](#improvements-2)

[Program Images](#program-images-2)

[Evaluation](#evaluation)

[Post-development testing](#post-development-testing)

# Glossary

Cuber(s) – a person (or group of people) who regularly play with a Rubik’s Cube

Speed Cuber(s) – a person (or group of people) who enjoy solving a Rubik’s Cube as fast as

Cubing – Solving, or attempting to solve, a Rubik’s

# GitHub

GitHub is an expansion upon the Git service which allow programs to be shared and collaborated on.

Git is a version history manager that allows you to edit expand upon your code without worry of breaking it, as you can simply rollback to a working version.

Whilst restrictions on school computers have made this difficult, I have tried my best to manage my Rubik’s cube project with Git and GitHub, and as such my code can also be found at [s-flegg/Rubiks-cube: My A-Level coursework project.](https://github.com/s-flegg/Rubiks-cube)

# Analysis of the problem

## Problem Identification

For my coursework project I am going to create a Rubik’s Cube game – the core principle of a Rubik’s “cube”, regardless of if they are a cube or not, is dividing each face of the shape into coloured shapes, with each face having a different colour. The rows and columns of the shape can then be rotated, mixing up the colours. The goal is to return the shape to its original state, with each face being only one colour.

The main focus of my game will be the traditional Rubik’s Cube, a 3x3x3 cube. Whilst some examples of this already exist, I believe many of the currently available options have clunky and confusing controls that make it harder to solve the Rubik’s Cube. They also tend to be rather barebones – lacking any additional features. As such, my goal for the program will be to provide a highly functional and easy to use program, that will hopefully provide users more enjoyment than other programs.

### Computational Approaches

I will be utilising abstraction to simplify the requirements into the barebones of what is required. This will allow for a more functional program with less unnecessary components that could confuse the user and/or make it harder to develop. For example, the first version of my cube will likely be a 2D net, as this can convey all the same information whilst being significantly easier to code. This makes it easier to make the code as problems are easier to understand and have less requirements. However, as I believe some less abstract features are crucial for the program – e.g. being able to show the cube in 3d – this abstraction will be removed in later versions. This will still make it easier to make the less abstract features as I can work up to them and have a reference as I make it.

Decomposition will also be used to significantly reduce the coding requirements. This involves breaking the code required to solve a problem into individual steps, or functions. This will allow for significantly less code as functions can be called multiple times. Additionally, it will make it easier to understand what each bit of code is doing in the case that it is later edited. For example, every possible way to interact with a cube can be achieved with 9 functions: 3 vertical turns, 3 horizontal turns, and 3 ways to rotate the entire cube. These functions can then build to other moves or be called directly.

I may also utilise concurrency. This means having multiple pieces of code running at the same time, for example the main Rubik’s cube code and perhaps a save feature that automatically updates in case that the program crashes/ failures. This will allow for things to be processed quicker as multiple things can be done simultaneously.

I will also utilise backtracking, as this will allow me to repeatedly develop and improve my code, from the entire program down to individual functions, whilst ensuring no major errors are made. I may use Git to do this, as this will allow me to easily make backups of my code with comments so that I know what changes between each backup.

## Stakeholders

| Stakeholder        | Represented Group                | How do they represent this group?                                                                                                          | Why have they been included?                                                                                                                                                                           |
|--------------------|----------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| James Brearly      | Speed Cubers.                    | They regularly solve a Rubik’s cube in under 2 minutes.                                                                                    | Speed cubers will likely be the second largest group of users and will have insights on the more competitive side of cubing.                                                                           |
| Jake Elmer         | Casual cubers.                   | They regularly attempt to solve a Rubik’s cube, having spent at least one hour or more attempting to solve one every week for over a year. | Casual cubers represent a large group of the people likely to utilise my program and will likely have insights about the convenience of the program.                                                   |
| Eddie Coulson      | Beginner cubers.                 | They are starting to regularly invest time in cubing but have spent less than 5 hours doing so in total.                                   | Beginner cubers can offer insight into the accessibility of the program for someone who knows none of the commonly used terms and perhaps doesn’t know how to solve a Rubik’s Cube                     |
| Connor Gilroy      | One-off cubers/ non-cubers.      | They have tried to solve a Rubik’s cube less than 5 times in their life, for a sum total of less than 1 hour.                              | People who have no interest in repeated use of the program will have more interest and suggestions about how initially accessible the program is, with less focus of more advanced/later-use features. |
| Sam Flegg (myself) | Rubik’s Cube program developers. | I am developing the program.                                                                                                               | As the developer of the program, I will have access to the source code and can therefore of code-related suggestions and improvements which end users will not be able to.                             |

## Research

### Questionnaire

To find out people’s opinions on a Rubik’s cube program and what features I could implement I have conducted a questionnaire. Candidates were asked to give brief and concise answers.

#### Template

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

4\. What do you like about solving Rubik’s Cubes?

5\. What don’t you like about solving Rubik’s Cubes?

6\. How do you think a Rubik’s cube could be more fun?

7\. What features would you like to see a Rubik’s cube program have?

8\. What concerns do you have about a Rubik’s cube program?

#### Result 1: Speed Cuber

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

1

4\. What do you like about solving Rubik’s Cubes?

They test my ability to think quicky and keep my mind engaged.

5\. What don’t you like about solving Rubik’s Cubes?

Quick/rough turns can sometimes cause pieces to fall off.

6\. How do you think a Rubik’s cube could be more fun?

Various size and shapes

7\. What features would you like to see a Rubik’s cube program have?

A timer and leaderboard

8\. What concerns do you have about a Rubik’s cube program?

Slow response times and not being able to turn the cube and see all of it

#### Result 2: Casual Cuber

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

3-4

4\. What do you like about solving Rubik’s Cubes?

They’re engaging and a fun challenge

5\. What don’t you like about solving Rubik’s Cubes?

They can be damaged or break apart

6\. How do you think a Rubik’s cube could be more fun?

Larger cubes

7\. What features would you like to see a Rubik’s cube program have?

The ability to change cube size

8\. What concerns do you have about a Rubik’s cube program?

Clunky interface

#### Result 3: Beginner Cuber

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

5

4\. What do you like about solving Rubik’s Cubes?

Intelligence test

5\. What don’t you like about solving Rubik’s Cubes?

Some scrambles can be really hard to solve

6\. How do you think a Rubik’s cube could be more fun?

Less hard scrambles

7\. What features would you like to see a Rubik’s cube program have?

Difficulty

8\. What concerns do you have about a Rubik’s cube program?

Weird interactions

#### Result 4: Non-Cuber

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

Normally give up

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

9

4\. What do you like about solving Rubik’s Cubes?

It’s a fun puzzles

5\. What don’t you like about solving Rubik’s Cubes?

They’re very difficult

6\. How do you think a Rubik’s cube could be more fun?

If it was easier

7\. What features would you like to see a Rubik’s cube program have?

A guide

8\. What concerns do you have about a Rubik’s cube program?

Too difficult

#### Result 5: Program Developer

1\. How many sessions of playing with a Rubik’s Cube do you have per month?

\<1 1-2 3-8 8+

2\. How long does it typically take you to solve a Rubik’s cube?

\<2 minutes \<10 minutes \<1 hour \>1 hour

3\. On a scale of 1-10, with 1 being very easy, how difficult do you find solving a Rubik’s cube?

7

4\. What do you like about solving Rubik’s Cubes?

Fun, engaging

5\. What don’t you like about solving Rubik’s Cubes?

Getting stuck/not knowing needed techniques

6\. How do you think a Rubik’s cube could be more fun?

More options

7\. What features would you like to see a Rubik’s cube program have?

Fully interactive cube, scrambler, solver, leaderboard, history, accounts, etc.

8\. What concerns do you have about a Rubik’s cube program?

Slow, inaccurate, doesn’t ‘feel’ like a Rubik’s cube.

#### Conclusion

After reviewing the questionnaire, people who solve many cubes a month and/or solve them quickly enjoy the challenge of solving the cube but due to their practice they find it easy. Therefore, I will investigate ways to make the cube harder, be it a guaranteed hard scramble, a larger cube, or some other technique. However, these people’s main concerns about their software are its functionality, suggesting they would be happy with a normal cube as long as it is at least as functional as a physical cube.

For more intermediate and beginner people who find it harder and solve less cubes, their main feature request is a way to reduce the difficulty, possible by implementing a guide. As I will very likely be implementing a solver, I may implement a hint button that can tell you the next move, or possibly moves, you should make.

### Useful technical approaches

To create my program, I will utilise python as his is the language I know. Python has many existing libraries that I can utilise to reduce the code requirements for this program. As Python is a very popular language and often utilised by new coders it is very well documented, allowing me to easily lean how to use any library I may need.

I will use Pygame for many- if not all – of the visual aspects of the game. Pygame is a popular library for making games and displaying elements. It allows for easily creating a window. It works primarily by having a game loop and events which you get() and handle yourself.

An example is: ![A screen shot of a computer code Description automatically generated](media/9fc1f6796b6d1304b788f93b2b5ea18f.PNG)

The above image shows code that uses pygame to create a white window. It also checks for the quit button being pressed, in which case the window closes.

If I create a login I will most likely use Tkinter as it has many features, making it easy to create a simple graphical login system. I highly useful aspect are the widget, which standardise the process for display various aspects such as text and entry boxes.

An example of the code used for a simple window is shown below.

![A computer screen shot of a program Description automatically generated](media/d3db9120dfb0b37ee1d9a71132ebdf46.PNG)

The above code, whilst simple, handles the creation of an entire resizable window.

I will also utilise object-orientated programming. This means creating classes that can contain data and functions shared between the objects made from them. Objects are instances of a class, and have access to the same data and functions. This makes it easy to create many similar things, A button – they look and function the same but do something different when pressed.

### Similar Programs

The following are 3 online Rubik’s cube programs that I have analysed. I have taken noted the good and bad features of each to ensure my program has all the necessary and good features and minimise the unnecessary functions.

#### Ruwik

[Online Rubik's Cube Simulator (ruwix.com)](https://ruwix.com/online-puzzle-simulators/)

![A screenshot of a computer Description automatically generated](media/53895428adbfbecbcb56a26ff226f8a0.PNG)![A cube with a logo on it Description automatically generated](media/f84d04925c88043ffd08f09d07bce5ec.PNG)

![A screenshot of a game Description automatically generated](media/05dd730c2d5014d87ee72f1906783feb.PNG)

1.  Ruwix has an option for all variety of cube types. This is a feature I would like to incorporate into my program; however, I believe it may greatly increase the time requirements. As such this will be one of the last features I will add if I add it at all.
2.  A solve function is a staple of a Rubik’s cube program and is a feature I will add to my program. However, Ruwix have incorporated it by having you make the cube layout, allowing you to solve cubes that are not a part of the program. I will likely have my solve function solve your current cube, removing the requirement to enter the cube layout but stopping you from entering non-program cubes.
3.  A stopwatch is useful for people curious about their solve time and especially speed cubers. This is an additional feature I hope to add to my program.
4.  Ruwix has a simple-looking controls guide. However, it requires users to know the correct terminology. I believe this creates an unnecessary barrier to entry for non and new cubers. Therefore, I will likely create a more intuitive guide for my program, perhaps a visual one to make it obvious what each button press does.
5.  A shuffle/scramble function is another stable of Rubik’s cube program, and will be one of, if not the first feature I add to my program.
6.  Ruwix has links to their other pages and social media. I believe this creates unnecessary visual clutter and creates an ugly UI. I will endeavour to avoid this in my program.
7.  Ruwix also allows for rotating the cube with the cursor. Whilst I like the idea of this it can often lead to the cube being slanted which is very hard to undo. Due to this I will likely only allow for fixed rotation.

#### Cube Solver

[Online NxN Rubik's Cube Solver and Simulator (cube-solver.com)](https://cube-solver.com/)

![A screenshot of a computer game Description automatically generated](media/f3d7fa31ea08d781c97a0cbcb25e8070.png)

1.  This is an option for other cube types/sizes. I believe this is a feature I should include in my program.
2.  This is an option to modify the animation speed. This offers more convenience for the users, and I would also like to include this, however this is not important overall.
3.  The black background is much easier to look at than the Ruwik’s one and something I would like to include. However, as this is largely down to user preference I will try to make it an option for the user.
4.  1) This is a link to a guide on how to solve a Rubik’s cube. Whilst I do not like the idea of linking to another website, I do the idea of an easily accessible guide.
5.  
6.  This allows you to recreate cube positions from other cubes/games. I will consider adding this feature.
7.  1) This shows steps to solve the cube and can do it automatically. Whilst I like it being automatic, it is incredibly unoptimized and can take hundreds of steps to solve a 5 move scramble. I will likely add a more optimised version of this.

    2) This is a link to an optimised solver; it requires you to input your cube position as it is a link to another website. I will not be implementing this.

8.  This scrambles the I will definitely add this feature.
9.  This allows you to reset the cube to its original position, also being solved. I had not considered this but will add this feature.
10. This program also has a 3d interactive cube, which I find to be much more responsive than the previous solution’s version. I will attempt to implement this.

#### Grubiks

<https://www.grubiks.com/puzzles/rubiks-cube-3x3x3/>

![A screenshot of a game Description automatically generated](media/affbcf9071bb4a100a9e82923865e0b6.PNG)

1.  This resets the cube. As mentioned on the last program, I had not considered this, but it is a useful feature I will include.
2.  A scramble button, a basic feature I will definitely include.
3.  Like with the first program, it has a 3d interactive cube that I find to be clunky and would rather have a non-interactive cube.
4.  This provides options for many different types of cubes, which is something I will try to implement.
5.  This provides solvers for each type of cube. Again, this requires manually creating the cube position which is something I want to avoid. I do however want a solver for each cube type I implement.

## Features

### Essential Features

#### The Cube(s)

The most important part of a Rubik’s program, the actual cube. I will implement a 3d cube which uses the keyboard as a controller. This will allow for having a 3d cube whilst avoiding the clunky interface that other programs had.

In addition to the standard 3 by 3 cube, I will add additional cube sizes. I will add 2 by 2 and 4 by 4 cubes, as well as non-cube variations. This allows for more variation in the program, helping prevent people getting bored.

#### Scrambler

Perhaps the most useful feature of the program, this allows people to have a cube they have to solve without having to scramble it themselves, meaning they can’t just undo the moves done to scramble it, as they don’t know them. This will utilise lots of randomness to ensure each scramble is different.

#### Solver

A common feature of Rubik’s cube programs, this will solve the Rubik’s cube. I will have this solve the current cube position instead of having the user input one, as I feel this makes it more accessible and easier to use. This can help people learn to solve cubes by showing them how to do it.

#### Tips/hints

I will implement a simple multi-stage guide to tell users what they should be attempting to do next to solve the cube. These stages will consist of multiple moves the user has to do by themselves. This will help the user learn how to solve the cube.

In the case a user gets stuck, there will also be a hint feature that utilises the solver to tell/show the use the next move they should do. This will help to ensure they do not get stuck and give up.

#### Timer

I will also implement an optional timer that starts of the first turn of cube and stops when the cube is solved. This will appeal to speed cubes allowing them to easily time themselves, thereby increasing the amount of people this program will appeal to.

#### Reset

A reset function will reset the cube to its default solved position and orientation, allowing users to quickly start again if they do give up on a cube.

#### Online leaderboard

I will implement an online leaderboard to encourage competition and giving users goals to strive for. I will have a leaderboard for each cube that shows the number of moves and the time taken.

#### Login System

A login system will allow for user scores to be saved as well as other user data. I will also add a guest

#### Guide

I will also need a guide, so players know how to play.

#### Save

I will add a save feature that will record and store the cube position.

#### Mouse Controls

I will attempt to add easy-to-use mouse controls.

#### Game History

This will allow users to track their progress and have measurable improvements.

### Limitations

#### 3D

Due to the limited amount of time and my unfamiliarity with 3D software in python, I am going to be unable to implement a true 3D interactive cube.

#### Multiple Cubes

As each cube would require its own logic and interactions, it would take an inordinate amount of time to implement multiple cubes. As such I am only going to implement a 3x3 cube.

#### Explained Tips/Hints

Due to the of possible scenarios and my limited knowledge on cubing techniques, it is outside of my capabilities to explain to the user why the next move is best.

#### Online Leaderboard

As I do not have the resources or money to host a server, I will have to limit this to a local leaderboard.

#### Mouse Controls

As I am not sure how I would add this whilst avoiding the ‘clunky’ experience I had on other programs and am concerned about time restrictions I will not add this.

### Requirements

#### Hardware

• 1.5 Ghz CPU or faster

• On-board graphics or any GPU

• 1 GB RAM

• 1080p display (recommended)

#### Software

• Python 3.11 or newer

• Pygame

• Tkinter

• Windows 7 or newer

#### Standard Cube

A standard 3 by 3 cube, that at the very least looks 3d if it isn’t, is a must. It is the centre point of the program and there is no point in the program without it.

#### Scrambler

This is a standard Rubik’s cube program feature, and my program would be incomplete without it.

#### Solver

Another common feature of a Rubik’s cube program, mine will implement an algorithm to ensure efficient solves.

#### Tips/Hints

As the solver will be implemented this will be able to utilise that, making telling the user the next best move trivial.

#### Timer

This is relatively simple in all aspects and thus there is little downside to adding it.

#### Reset

Another feature that is trivial to add, only requiring a default state I can revert the cube to and wiping any move history.

#### Local Leaderboard

A local leaderboard should be included so people on the same device may compete with each other.

#### Login System

As I have made a login system in lesson it will be easy to adapt for my program

#### Guide

This is an important feature to add as otherwise users would have to discover how the program works by themselves.

#### Save

Utilising the login system, this shouldn’t be too hard to add, and will make the program more accessible as games can be stopped and continued later.

#### Game History

This should be reasonably simple to add, and I consider it an important feature for user retention.

## Success Criteria

• There should be a professional looking visual representation of a 3-dimesional Rubik’s cube as this is the core of the program and a non-standard cube layout (e.g. a net) may confuse users.

• The cube should have the correct logic - the result of any moves should match the result of performing the move on a real Rubik’s cube.

• There should be a scramble feature able to produce a scramble for the user to solve. The scramble must be possible to solve.

• A solver feature should be included. This should be able to solve the cube move by move, allowing the user to see the steps required to solve it so they may learn from it.

• A hint feature should tell the user the next move they should make if they require help, as to decrease the chance that the user simply gives up.

• A timer function should be included to incentivise competitiveness. In line with this the timer must be as easy to use as possible, it should not cause any delays. It will automatically start upon the user’s first move and automatically stop when the cube is solved.

• A local leaderboard will be included to allow people to compete. This should display, at a minimum: the ten quickest solve times, the respective usernames, and number of moves required.

• The leaderboard should only include solves that did not utilise the hint or solve functions.

• There should be a straightforward login system that utilises encryption and/or hashing for security.

• There should be a clear and concise guide to using the program to prevent any confusion.

• There should be a simple to use save function to allow users with limited time to play whenever they wish without worrying if they have enough time for a complete solve.

• The save function should be able to run automatically to prevent users from losing progress should they forgot to save or something unexpected happens – e.g. power loss.

• A game history function should be included to allow users to see how they have progressed overtime.

# Design

## Problem Decomposition

### Table

| Sub-problem                                    | Why this is suitable                                                                                                                                                                                                   | Parent problem(s) | Child problem(s)       |
|------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|------------------------|
| 0 – Rubik’s Cube Program                       | It is the entire program and requires decomposing                                                                                                                                                                      | N/a               | 1, 12                  |
| 1 – Login page                                 | This is important to allow users to have their own accounts and has many complicated aspects                                                                                                                           | 1                 | 2, 6, 10               |
| 2 – Sign in with existing account              | Users need to be able to access their account                                                                                                                                                                          | 1                 | 3                      |
| 3 – Verify username and password               | The entered details must be checked against stored encrypted and/or hashed details                                                                                                                                     | 2                 | 4, 5                   |
| 4 – Load account details                       | The account details must be retrieved from a file and prepared for that user                                                                                                                                           | 3                 | 12                     |
| 5 – Offer alternative options                  | The user must be able to rectify a mistake when logging in                                                                                                                                                             | 3                 | 2, 6                   |
| 6 – Create new account                         | New users must be able to create an account to have access to all the features an account offers                                                                                                                       | 1, 5              | 7                      |
| 7 – Check details are valid                    | The details entered must be able to be handled by all the code that may interact with it, including the code for logging in. E.g. the username must be unique                                                          | 6                 | 8, 9                   |
| 8 – Create user’s account                      | The new account must be created, with files in the appropriate format showing no game history, saves, etc.                                                                                                             | 7                 | 12                     |
| 9 – Display correct error message              | The user must be informed why the details are invalid and how to fix their mistake                                                                                                                                     | 7                 | 6                      |
| 10 – Guest option                              | For new users who may not yet want to create an account must be a way for them to still use the program                                                                                                                | 1                 | 11                     |
| 11 – Generate temporary account                | A temporary account with no previous details that will only exist while in use must be created                                                                                                                         | 10                | 12                     |
| 12 – Start game                                | The core of the program, containing all the features of the game                                                                                                                                                       | 0                 | 13, 31, 38             |
| 13 – Display cube and buttons                  | The cube and button icons must be loaded and displayed for the user to see                                                                                                                                             | 12                | 14, 16                 |
| 14 – Detect keyboard inputs                    | Any inputs from the keyboard must be detected and handled, as this is the user’s primary way of interacting with the program                                                                                           | 13                | 15                     |
| 15 – Update Cube                               | The turns/rotations indicated by the user via the keyboard must be executed                                                                                                                                            | 14                | N/a                    |
| 16 – Detect button presses                     | The user’s secondary method of interacting with the program, this is how they will access the additional features                                                                                                      | 13                | 17, 18, 19, 20, 22, 27 |
| 17 – Load 3D cube                              | The core program should be loaded for the user to interact with                                                                                                                                                        | 16                | N/a                    |
| 18 – Load cube guide                           | A simple guide for the user should be loaded, allowing them to learn how to use the program                                                                                                                            | 16                | N/a                    |
| 19 – Perform a random set of moves             | Multiple random moves need to be executed to scramble the cube, providing the user a challenge to try and solve                                                                                                        | 16                | N/a                    |
| 20 – Calculate the next step to solve the cube | This will require a large algorithm to evaluate what the next step should be                                                                                                                                           | 16                | 21                     |
| 21 – Repeat until solved                       | The algorithm in step 20 needs to be rerun until the cube is solved, meaning this process must also be able to recognise when the cube is solved                                                                       | 20                |  N/a                   |
| 22 – Load game history from file               | The user’s username must be searched from a file, found, and then all the corresponding data must be parsed into the program, all whilst being reasonably fast                                                         | 16                | 23                     |
| 23 – Display game history                      | The user’s game history must be displayed in a user-friendly manner without affecting the user’s ability to use the program                                                                                            | 22                | 24, 25, 26             |
| 24 – Date and time started                     | The date and time are crucial for the user to be able to track their progress                                                                                                                                          | 23, 28            | N/a                    |
| 25 – Time to solve                             | The time to solve is the main way to measure someone’s skill at cubing                                                                                                                                                 | 23, 28            | N/a                    |
| 26 – Moves to solve                            | Moves to solve is another method to measures someone’s skill at cubing, and whilst not as popular, it is a more accessible for people                                                                                  | 23, 28            | N/a                    |
| 27 – Load leaderboard data from file           | The ten lowest times to solve and ten lowest moves to solve must be loaded from a file, meaning the entire file must be searched, but this must be done quickly                                                        | 16                | 28                     |
| 28 – Display leaderboard                       | Multiple pieces of data need to be presented in a reasonable manner which allows the user to see all the important information without crowing the screen and limiting the user’s ability to interact with the program | 27                | 24,25,26, 29           |
| 29 – Username                                  | The username is important so that people can see who they are competing against and be inclined to challenge them                                                                                                      | 28                | N/a                    |
| 30 – Detect player started                     | The timer function must start running immediately after the user’s first cube interaction, meaning this function must either always be checking for a cube interaction                                                 | 12                | 31                     |
| 31 – Start timer                               | The timer must be started in a manner that will persist while the program runs and will not be affected by things like frame rate                                                                                      | 30                | 32                     |
| 32 – Detect player finished                    | The cube state must be checked after every move by the user to see if it is solved                                                                                                                                     | 31                | 33                     |
| 33 – Stop timer                                | The timer must be stopped, and the time taken recorded                                                                                                                                                                 | 32                | 34, 35                 |
| 34 – Update leaderboard                        | The leaderboard must be updated with the date and time, time to solve, moves to solve, and user’s username.                                                                                                            | 33                | N/a                    |
| 35 – Update game history                       | The user’s game history must be updated with the time taken, moves taken, and the data and time.                                                                                                                       | 33                | N/a                    |
| 36 – Detect cube interaction                   | After each move on the cube the save function should be run                                                                                                                                                            | 12                | 37                     |
| 37 – Save cube position                        | The complete cube position must be saved in a file so that the exact cube position can be recalled at a later date                                                                                                     | 36                | 38                     |
| 38 – Save time passed                          | The amount of time passed and move count must also be saved so that they can continue being updated when the game continues                                                                                            | 27                | N/a                    |

### Flowchart

The following flowchart has been designed using decomposition to help show the logical steps of the program and to see where similar steps exist so one function can be coded to complete each , decreasing the code requirement.

![A black screen with white text Description automatically generated](media/cef95eb28572767e22621a643f8697ea.png)

## Solutions

### Sorting Algorithms

A sort algorithm moves each element in a list so that they follow an order. Each algorithm described will assume sorting from smallest to largest, although this may not be the case in my program.

#### Bubble

Bubble sort involves going to each element and repeatedly swapping it with the element after it if the element after it is smaller. Time complexity O(n\^2), space complexity O(1).

![A computer screen shot of a code Description automatically generated](media/2b3357759d09376a3832ca49c938780d.png)

#### Insertion

Insertion sort works by creating a sub-list at the start of the list with initial length 0, and then moving adding each element that is out of the sub-list into the sub-list, placing it in order as this is done, until the sub-list is the entire list and in order. Time complexity O(n\^2), space complexity O(1).

![A screen shot of a computer code Description automatically generated](media/069f691e49a01998766331351d4912d2.png)

#### Merge

Merge sort works by recursively splitting the list until each list has length one, and then combining each list and placing the elements in order as this is done, until all lists are sorted back into one list. Time complexity O(n log n), space complexity O(n).

![A computer screen shot of a code Description automatically generated](media/ec636fc5650f644d28670814b6b54d5f.png)

#### Quick

Quicksort works by picking any element of the list as a pivot, and then moving all smaller elements to the left of the pivot and all larger elements to the right of the pivot. Then each side of the pivot is considered as a sub-list and recursively quick sorted, until each sub-list has length one, when the list will be sorted. Time complexity O(n log n), space complexity O(log n).

![A computer code with white text Description automatically generated](media/88a6084a5d8c82ef9c6816e504ed49cc.png)

### Searching Algorithms

A search algorithm finds the position of an element in a list. The 2 I may be using have space complexity of O(1).

#### Linear

Linear search works by starting at position 0 of the list and moving to the next element until it matches the desired element. Time complexity O(n)

![](media/1b21bf426d367e8433aaa4115c5f0094.png)

#### Binary

Binary search works by repeatedly splitting an ordered list. It starts by looking at the middle of the list. If the element is found, the middle of the list is its position. If the element being looked at is lower than the desired element (assuming the list is ordered smallest to largest), then considers everything to the right of the list as a sub-list (using low and high points), and then repeats the process. Time complexity O(log n).

![](media/c9e0791e36fbecca8533d4d8b6af05aa.png)

### Cube Algorithms

#### Image

I will need to have an algorithm to create the image of cube. It may draw the cube as well, or if it does not it will return the image of it. I will decide which it does when I have started developing my program and have a better idea of how it will work, although I imagine it will work via return. The image will be gotten by drawing each individual square on the cube onto a surface, with their colour being dictated by a 3d array.

#### Turns

When the user inputs their move I will need to have a function to process this. It will need to update a 3d array that stores the cube’s state, correctly swapping or maintaining the colour stored in each position. I may use the numpy library to help with this, as it has many functions for working with arrays, which my Rubik’s cube will use.

#### Rotations

When the user inputs a rotation the cube array needs to be updated so that each face is moved to do this rotation. However, it needs to appear to the user as the cube is unchanged, and that they are simply looking at a different part. The turns function may be useful for this, although I will have to ensure there is nothing to indicate to the user that the turns function has been used (e.g. if the number of moves is recorded, this should not be updated)

#### Scramble

There should be a function that randomises the cube state to provide a cube for the user to solve. As such, the scramble function should also ensure the cube state produced is one that is possible to solve. I will use a series of turns to scramble the cube to ensure that the cube is possible to solve as each turn would solve the cube. This will likely utilise the random library to help ensure the cube state produced is truly random and not biased by me.

#### Solver

The program is also meant is also meant to have a solver. After some research I have found the best method for this is likely a long algorithm consisting of many if statements that is run repeatedly until the cube is solved. However, this would take a long time and be tedious to implement. As such, I may initially use a stack consisting of every move the user has done and what moves were done to scramble the cube, and then I could pop elements from the stack and do the opposite of them to solve the cube. This method would be inefficient and may take much longer to solve the cube than required, but it would be a lot easier to implement initially, and I could look into implementing the ‘proper’ algorithm in later versions.

#### Hints

The hint function may be able to utilise the solver and simply get the next move from that function, although this may require editing the solve function slightly to allow a single move to be gotten.

#### Timer

The timer needs to be automatically triggered when the users , although starting could be defined as either when the scramble function finishes or when the user makes their first move. I believe it would be easier to start the timer when the scramble function finishes so this is what I will do initially, however the World Cube Association allows contestants some time to inspect the cube scramble before they must start solving it, so I believe the correct thing to do would be to start the timer when the user makes their first move. As such I will endeavour to implement this in my later versions. However, this may not be something that is appropriate in the timer itself, and instead the automatic starts and stops may be managed by a different section of code. The timer itself needs to manage creating a timestamp of when the timer is started, and tracking the amount of time passed since then, and stopping the timer when required.

#### Leaderboard

The leaderboard function will need to check all users solves to sort them from quickest to slowest, and check if they are eligible to be on the leaderboard (they mustn’t have used the solve or hint feature). As more and more solves are recorded the time taken to do this will increase, potentially eventually taking an unreasonable amount of time. As such, I will create a sorted list of the top ten quickest eligible solves (which may be changed to a leaderboard of every solve in a later version) which every solve will be checked against at the time of solve to see if the list needs to be updated. This way loading the leaderboard will take the same amount of time regardless of how many users solves there are as all that needs to be done is a list must be loaded.

#### Login

A login system must also be implemented to manage users and their associated data. From some of my previous coding projects I have a premade login system which I can import and utilise instead of creating another login system. However, this login system is far from perfect, so in my later versions of the project I may improve this login system or simply find a better one.

Initially I will use my premade one which will call a function with a username as a parameter, so I will need to create user system that has an appropriate function to load the user’s data into the program and will store the user’s game related data, as my login system only handles login data.

#### Guide

The program will require a guide to instruct users on how to use the cube. To achieve this, I will get the image a default cube by reusing the function for getting the actual used cubes image and then add arrows to the image to show what turns and rotations will be done for corresponding key presses.

#### Save

A save function should save users progress so that they may return to a solve they are in the middle of if they have to leave for any reason/they run into any computer problems. The save function should run automatically, and not run to often so as to not cause performance issues. To do this I may use threading to allow the save function to run (and sleep) in the background so as to allow the main program to run uninterrupted.

#### Game history

There should be a game history function to allow users to see their past games and progress. This must get data from a user’s data file and parse it out to display data about past games in a manner the user understands. This therefore also necessitates saving data about every attempted solve, which will require getting the time taken, moves taken, cube state (which will be a 3d array), and possibly the original scramble.

## Useability Features

Useability features are important to ensure the game is fun and accessible to everyone. If users have to spend too long learning how to use the program, they may get bored and stop using the program, or have servery decreased enjoyment.

As such, I will be using simple keyboard controls for the main part of the game, as this is the simplest and most accessible method of interaction for many inputs, and unlikely to prevent anyone from being able to play or causing any confusion.

I will also be utilising simple point and click navigation of the program and large, sometimes graphical, buttons, are these are also simple to understand, and point and click navigation is the standard that most people will be familiar with.

## Data and Variables

| Variable Name | Type                    | Description                                                                                                                                                                                                             | Sample                                                                                                                 |
|---------------|-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| width         | Int                     | The screen width, useful for creating the game window and positioning elements to be placed on it                                                                                                                       | 1600                                                                                                                   |
| height        | Int                     | The screen width, useful for creating the game window and positioning elements to be placed on it                                                                                                                       | 900                                                                                                                    |
| screen        | Pygame.Surface          | The displayed screen on which every item to be displayed must be placed                                                                                                                                                 | N/a                                                                                                                    |
| used_cube     | 3D array                | This array will represent the cube and store the colour at each position.                                                                                                                                               | ![A blue screen with white text Description automatically generated](media/dae6c918117dabe78f47520d6ca9a5bd.png)       |
| BLACK         | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (0, 0, 0)                                                                                                              |
| WHITE         | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (255, 255, 255)                                                                                                        |
| YELLOW        | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (255, 255, 0)                                                                                                          |
| ORANGE        | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (255, 165, 0)                                                                                                          |
| RED           | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (255, 0, 0)                                                                                                            |
| GREEN         | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (0, 255, 0)                                                                                                            |
| BLUE          | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (0, 0, 255)                                                                                                            |
| GREY          | Tuple                   | This will store the RGB value of the colour to be used throughout the program. As this is a colour it will be stored as a constant.                                                                                     | (169, 169, 169)                                                                                                        |
| Cube3D        | Class                   | This will manage creating the image of the 3D cube and drawing it, as well as updating the image and storing the position it should be drawn to (as this is unlikely to change in my program)                           | ![A screen shot of a computer program Description automatically generated](media/5f86d0853827dde702d0dc6ce086eab3.png) |
| CubeGuide     | Class                   | Similar to Cube3D, CubeGuide will manage the drawing and updating the guide cube, and storing data, although instead of making the guide cube image from scratch this class will utilise inheritance and polymorphism.  | ![A screen shot of a computer program Description automatically generated](media/8c9acd23636c5505989629f8b9f67231.png) |
| default_font  | Pygame.freetype.sysfont | default_font will hold the main font I will use throughout my program to display text, to ensure it is consistent throughout.                                                                                           | default_font = pygame.freetype.SysFont("calibri", 15)                                                                  |
| moves         | Stack (list)            | moves will store every move the player makes so that the solve function can pop and undo moves repeatedly to solve the cube for the user.                                                                               |                                                                                                                        |

## Validation

Throughout the program I will need to validate various aspects.

One thing I will validate is screen positions. A position that an image is going to be blitted to should be validated to ensure it is on the screen. This will raise an error in case an invalid screen position is calculated.

Another form of validation is handling invalid key presses. Pygame itself handles this, as all key presses are added to the events list with their key recorded as type. You can then simply check for events with the key type of keys that are supposed to be used, and any other key presses will simply be ignored.

The last form of validation will be used with the image of the cube used for the guide cube. I want to display the default cube for the guide image\_ and I don’t want it to be able to be changed. To achieve this, I will check if the guide cube image is being displayed and ignore any cube interactions if it is.

## Iterative-Development Test Data

Due to how difficult it would be ensure that the changes to a 3D array correctly match a real Rubik’s cube, and how reliant on visual output my program is, am going to test some elements based on their display to a pygame window.

| Test No. | What is being tested                   | Description                                                                                                                                                                                          | Method                                                                                                                                                                                                                                                                               | Expected Output                                                                                                                             | Pass/Fail |
|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| 1        | 3D cube algorithm                      | There should be an image algorithm that either returns a pygame.Surface containing an image of the display the cube to the screen.                                                                   | Blit the image returned by the function to the screen or call the function, inside the main game loop.  Repeat whilst making changes to used_cube.                                                                                                                                   | An image should be and it should match used_cube.                                                                                           |           |
| 2        | Cube turn – vertical, left, up         | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated upwards.                                                              | Execute the turns function with the parameters for the turn. Run the cube display, the display should show the new cube state. The same rotation should be done to a real Rubik’s cube.                                                                                              | The image of both cubes should be exactly the same.                                                                                         |           |
| 3        | Cube turns – vertical, middle, up      | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated upwards.                                                                |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 4        | Cube turns – vertical, right, up       | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated upwards.                                                             |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 5        | Cube turns – vertical, left, down      | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated downwards.                                                            |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 6        | Cube turns – vertical, middle, down    | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated downwards.                                                              |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 7        | Cube turns – vertical, right, down     | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated downwards.                                                           |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 8        | Cube turns – horizontal, top, right    | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated right.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 9        | Cube turns – horizontal, middle, right | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated right.                                                                     |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 10       | Cube turns – horizontal, bottom, right | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated right.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 11       | Cube turns – horizontal, top, left     | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated left.                                                                       |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 12       | Cube turns – horizontal, middle, left  | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated left.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 13       | Cube turns – horizontal, bottom, left  | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated left.                                                                       |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 14       | Scramble                               | The scramble function should randomly position the individual squares whilst still ensuring that the cube is solvable.                                                                               | Add a delay between each move in the scramble function. Run the scramble function and follow along with a real Rubik’s cube.                                                                                                                                                         | Each move done by the scrambler should be possible on the real Rubik’s cube.                                                                |           |
| 15       | Solver - solving                       | The solve function should solve the cube, showing the user each step, ensuring that each move is possible and not simply changing the used_cube to fit as needed.                                    | Manually scramble the cube, doing each move to a real Rubik’s cube as well. Run the solver and follow the moves on the Real Rubik’s cube.                                                                                                                                            | Each move done by the solver should be possible on the real Rubik’s and at the end the cube should be solved.                               |           |
| 16       | Solver – stop solving                  | If used_cube reaches a solved state, the solver should stop solving, regardless of if there something such as a moves list indicates there are more moves to do to solve the cube.                   | Manually scramble the cube, ensuring that you return to a solved state at least once then scramble from there. Run the solver.                                                                                                                                                       | The solver should stop when it reaches the first solved state.                                                                              |           |
| 17       | Check solved                           | There should be a function to check if a cube state is solved or not.                                                                                                                                | Test the function using multiple different cube states, some of which are manually or automatically scrambled.                                                                                                                                                                       | The outputs should match the given cube state.                                                                                              |           |
| 18       | Hints                                  | The hint function should complete one move towards the solve. It must only be one and it must help solve the cube.                                                                                   | Scramble the cube then run the runt the hint function. Note the move that it makes. Undo that move and then run the solver (test 15 must have passed).                                                                                                                               | Only one move should be completed by the hint function. The move should match the one done by the solver.                                   |           |
| 19       | Timer – time elapsed                   | The timer should correctly record the amount of timer that has passed since it started                                                                                                               | Start the timer. Wait for 10 seconds (counted via a trusted, real, timer). Print the time elapsed.  Repeat a few times with various amounts of time waited.                                                                                                                          | The trusted timer and the timer being tested should have a matching (or very similar, to account for human error) times.                    |           |
| 20       | Timer – auto start                     | The timer should automatically start upon scramble.                                                                                                                                                  | Scramble the cube. Solve the cube. Scramble the cube, use hint function. Scramble the cube. Use the solve function. Scramble the cube.  Monitor the time elapsed during this.                                                                                                        | Each time the cube is scrambled the timer should start,                                                                                     |           |
| 21       | Timer – auto stop                      | The timer should automatically stop upon being solved.                                                                                                                                               |                                                                                                                                                                                                                                                                                      | Upon being solved and when the solver is used, the timer should stop. The timer should not stop if these do not occur.                      |           |
| 22       | Leaderboard – Eligibility check        | Each entry should be checked to see if they are faster than the slowest time on the leaderboard, to see if they have made it onto the leaderboard.                                                   | Submit a completion with a slower completion time than the slowest. Submit a completion with a faster time than the slowest. Submit a completion time identical to the slowest.                                                                                                      | Only the completion with the faster time should be considered for updating the leaderboard.                                                 |           |
| 23       | Leaderboard – add entry                | If the leaderboard isn’t full any completion should be added to the leaderboard. If the leaderboard if full and entry is eligible, the new entry should replace the slowest time on the leaderboard. | Add an entry when the leaderboard is empty. Add an entry when the leaderboard is half full. Add an entry when the leaderboard is full.                                                                                                                                               | The first two entries should be automatically added to the leaderboard. The last entry should replace the slowest entry on the leaderboard. |           |
| 24       | Leaderboard – sort leaderboard         | When a new completion is added to the leaderboard, the leaderboard needs to be sorted to ensure that completion ends up in the correct position. The list should be ordered by ascending times.      | Sort the leaderboard when it is already in order. Sort the leaderboard when it is in descending order. Sort the leaderboard when it is randomised. Sort the leaderboard when 2 identical times exist.                                                                                | Each leaderboard should end up sorted. Manually check this.                                                                                 |           |
| 25       | Leaderboard – save times               | The ordered list of leaderboard times should be able to be saved to a text file so that they are kept even when the program ends.                                                                    | Save the leaderboard when it is empty. Save the leaderboard when it has no completions. Save the leaderboard when it is half full. Save the leaderboard when it is full.  In each case close the program and start it again, attempting to load these saves.                         | In each case the text file should be updated with the leaderboard.                                                                          |           |
| 26       | Leaderboard – load saved times         | The saved leaderboard times need to be able to be loaded so they can be displayed and be checked against for any new records.                                                                        |                                                                                                                                                                                                                                                                                      | In each case the leaderboard should be updated to match the text file.                                                                      |           |
| 27       | Guide algorithm -                      | The should either be a function that returns a pygame.Surface or a procedure that draws the image to the screen.   The image should show how to use the cube.                                        | Either blit the pygame.Surface to the screen or call the procedure inside a game loop.                                                                                                                                                                                               | An image should be displayed.                                                                                                               |           |
| 28       | Guide algorithm – prevent moves        | The cube image should only display the default cube and as such it should not allow cube interactions to happen when the guide is being displayed.                                                   | When displaying the cube, try the following: turns, rotations, scrambling and solving.                                                                                                                                                                                               | None of the functions should work. The cube should remain unchanged.                                                                        |           |
| 29       | Save – to file                         | The save algorithm should be able to save all the key data to a text file.                                                                                                                           | Use the save function with a variety of different key information, including extreme test data such as the timer being at 0.0 seconds and the cube already being solved.  In each case attempt loading the program with this saved data, ensuring it is loaded as current game data. | The save file should be updated to include the key data for the user.                                                                       |           |
| 30       | Save – load form file                  | The save algorithm should be manage loading the data from the text file and updating game values so it is as if the saved state has been achieved in the current session.                            |                                                                                                                                                                                                                                                                                      |                                                                                                                                             |           |
| 31       | Save – autosave                        | The save function should automatically run periodically.                                                                                                                                             | Start a game and make some changes to the cube. Then wait the amount of time set between saves. Once this time has passed closer and reopen the program.                                                                                                                             | The cube should be in the same state as it was when the program was closed,                                                                 |           |
| 32       | Game history                           | When a solve is complete, either by the solve function being used, the scrambler being used, or the cube being solved, the data about that solve should be saved to a list of solves.                | Finish a solve using the solver, scrambler, and by solving manually.                                                                                                                                                                                                                 | These three solves should be added to game history list.                                                                                    |           |

## Post-Development Test Data

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|   |   |   |   |   |   |
|   |   |   |   |   |   |
|   |   |   |   |   |   |
|   |   |   |   |   |   |
|   |   |   |   |   |   |

### Test plan

Post development tests will focus on stakeholder

| Test No. | What is being tested                           | Description                                                                                      | Pass criteria                     | Stakeholder responses. | Pass / Fail |
|----------|------------------------------------------------|--------------------------------------------------------------------------------------------------|-----------------------------------|------------------------|-------------|
| 33       | 3D cube – image. Function.                     | There is a 3D representation of a cube.                                                          | All stakeholders must answer yes  |                        |             |
| 34       | 3D cube - professionalism                      | The 3D cube must look professional.                                                              | Avg. score \>= 70%                |                        |             |
| 35       | Logic – possible states. Function.             | It must be possible to reach every possible cube state.                                          | All stakeholders must answer yes. |                        |             |
| 36       | Logic – possible moves. Function / Robustness. | All moves able to be done to the cube must be possible on a real Rubik’s cube.                   |                                   |                        |             |
| 37       | Controls - cube. Useability.                   | The controls for interacting with the cube must be simple and intuitive.                         | Avg. score \>= 70%                |                        |             |
| 38       | Controls – program. Useability.                | The controls for interacting with the program must be simple and intuitive.                      |                                   |                        |             |
| 39       | Scramble. Function.                            | There must be scramble function to scramble the cube.                                            | All stakeholders must answer yes. |                        |             |
| 40       | Solver – solves cube. Function.                | There must be a solve function that solves the cube.                                             |                                   |                        |             |
| 41       | Solver – showcase moves. Function.             | The solve function must show each move being done to solve the cube in an understandable manner. | Avg. score \>= 70%                |                        |             |
| 42       | Hints. Function.                               | A hint feature should show the user the next move to make.                                       | All stakeholders must answer yes. |                        |             |
| 43       | Timer – timing. Function.                      | A timer should be available to time solves.                                                      |                                   |                        |             |
| 44       | Timer – autostart. Useability.                 | The timer automatically starts.                                                                  |                                   |                        |             |
| 45       | Timer – autostop. Useability.                  | The timer automatically stops.                                                                   |                                   |                        |             |
| 46       | Leaderboard – image. Function.                 | There is a leaderboard.                                                                          |                                   |                        |             |
| 47       | Leaderboard – solves. Function.                | The leaderboard should display the ten quickest solve times or more, in ascending order.         |                                   |                        |             |
| 48       | Leaderboard – details. Function.               | Each entry must display: username, the number of moves required, the time taken.                 |                                   |                        |             |
| 49       | Login System – logs in. Function.              | There should be a login system that allows users to login in.                                    |                                   |                        |             |
| 50       | Login System – straightforward. Useability.    | The login system should be straightforward and easy to use.                                      | Avg. score \>= 70%                |                        |             |
| 51       | Save – loading. Function.                      | Upon logging in user data should be loaded.                                                      | All stakeholders must answer yes. |                        |             |
| 52       | Save – automatic. Useability.                  | The save function should run automatically.                                                      |                                   |                        |             |
| 53       | Guide – exists. Function.                      | There must be a guide that shows how to use the program.                                         |                                   |                        |             |
| 54       | Guide – user display. Useability.              | The guide must be clear and concise.                                                             | Avg. score \>= 70%                |                        |             |
| 55       | Game history – exists. Function.               | There must be a game history function that displays previous game history,                       | All stakeholders must answer yes. |                        |             |
| 56       | Game history – usefulness. Function.           | The game history function must make it easy to see how you have progressed over time.            | Avg. score \>= 70%                |                        |             |

### Quiz template

| Stakeholder name: |                                                                                                                 |             |                    |
|-------------------|-----------------------------------------------------------------------------------------------------------------|-------------|--------------------|
| Test no.          | Question                                                                                                        | Answer type | Stakeholder Answer |
| 33                | Is there a representation of a 3D cube?                                                                         | Yes or No   |                    |
| 34                | How professional does the 3D cube look?                                                                         | 1 to 10     |                    |
| 35                | To your knowledge, is every move that’s possible on a real Rubik’s cube possible on the program’s Rubik’s cube? | Yes or No   |                    |
| 35                | To your knowledge, is every move possible on the program possible on a real Rubik’s cube?                       |             |                    |
| 37                | How well do the cube controls meet the description: simple and intuitive?                                       | 1 to 10     |                    |
| 38                | How well do he program controls meet the description: simple and intuitive?                                     |             |                    |
| 39                | Is there a scramble function?                                                                                   | Yes or No   |                    |
| 40                | Is there a solve function?                                                                                      |             |                    |
| 41                | How well does the solve function show each move done (in regards to you being able to understand it)?           | 1 to 10     |                    |
| 42                | Is there a hint function that shows you the next move to make?                                                  | Yes or No   |                    |
| 43                | Is there a timer to track how long solves take?                                                                 |             |                    |
| 44                | Does the timer start automatically?                                                                             |             |                    |
| 45                | Does the timer stop automatically?                                                                              |             |                    |
| 46                | Is there a leaderboard?                                                                                         |             |                    |
| 47                | Does the leaderboard show the ten quickest solves in ascending order?                                           |             |                    |
| 48                | Does each leaderboard entry display: the username, the time taken, the moves taken?                             |             |                    |
| 49                | Is there a login system?                                                                                        |             |                    |
| 50                | How straightforward to use is the login system?                                                                 | 1 to 10     |                    |
| 51                | Is your user and game data loaded when you log in?                                                              | Yes or No   |                    |
| 52                | Does the save function run automatically?                                                                       |             |                    |
| 53                | Is there a guide to use the program?                                                                            |             |                    |
| 54                | How clear and concise is the guide?                                                                             | 1 to 10     |                    |
| 55                | Is there a function to see your game history?                                                                   | Yes or No   |                    |
| 56                | How easy does the game history function make it to see how you have progressed?                                 | 1 to 10     |                    |

# Implementation

## Prototype One

To begin I will create a simple cube net with the purpose of testing the cube logic. This will be a very graphically simple cube with few features, but it will allow me to test the most important part of my program.

### Development

Cube Display (Net, not 3D):

• [Window](#ProtypeOneDisplayWindow) for display

• Cube [image](#ProtypeOneDsiplayCube)

Cube Logic:

• Data [storage](#ProtypeOneLogicStorage)

• Data [manipulation](#ProtypeOneLogicRotations)

Validation:

• Validation [function](#ProtypeOneValidation)

• Function [usage](#ProtypeOneValidationUsage)

• [Ignore invalid key presses](#ProtypeOneValidationIgnoreInvalidKeyPres)

![A screenshot of a computer program Description automatically generated](media/348cfddefb0c85d69bc95877b46ed183.png)

![A screen shot of a computer Description automatically generated](media/02154d377b0f2e58c326b4f0a2e5143e.png)

In this section of code, I have initially imported the necessary libraries for later use in the program and then defined some colour’s RGB values. The variable names of the colours have been written in all caps to signify that they are constants. Additionally, they have been written as tuples instead of lists as tuples are immutable.

I have then manually defined the default cube, creating a 2D array for each face, and then combined these into a 3D array. This could have been achieved by using loops, however this method provides a more visual representation of the cube and reduces the risk of an error during this section, allowing me to focus on developing the logic and functions required for the cube. I have called this variable ‘default_cube’ as it is the starting (solved) position of the cube and will be used for checking if the cube is solved – which will be important for the solver, leaderboard and game history. I have then created a deep copy of the cube called ‘used_cube’, which is the cube that will be updated and changed by user actions. A deep copy was used as this creates a new array by value instead of reference, ensuring default-cube is not changed by actions done to ‘used_cube’.

![A computer code on a black background Description automatically generated](media/77c73528097dcedd8d346a84bddec896.png)In this section I have created a pygame window for displaying the cube. I have defined width and height as variables as these will be used for positioning images later. I also created the ‘default_colour‘ variable so that I can easily change the background colour without majorly altering the program, which may help with adding it as a feature if that is something I wish to-do at a later date. This is crucial for displaying the cube and all features associated with it.

![A computer screen with text and images Description automatically generated](media/e177f1ef5df5b51c21508cded13f0af7.png)

In this section I have designed a function validate screen positions, ensuring that if a screen position is outside the bounds of what is reasonably expected the program will end. This will be largely redundant in prototype one, due to the static nature of the window being displayed to, however it will become useful in later versions that implement resizable windows, and feature more calculations to display elements, increasing the likelihood of error. Additionally, as prototype one is a small program I could easily test this function without something else causing an error first.

I chose a 4k resolution (3840 x 2160) as this is the largest resolution commonly used by computer monitors – the intended display.

![A screen shot of a computer program Description automatically generated](media/227329e4a4ec7d751e52c98e8e3004d4.png)

![A screen shot of a computer screen Description automatically generated](media/458146fe119bc5aba4d78a2f11656f0f.png)

This section serves to create and display a simple cube, although this one is not 3D.

In this section I have coded a function ‘cube’ that will blit the image of the cube onto the screen. The function has ‘colour_3d_array’ as a parameter, it is a 3D array of RGB tuples, wanting either ‘used_cube’ or ‘defaut_cube’ to be given. It works by breaking the 3D array down into single elements, creating the necessary image, and then recombing these images to form a cube. To do this I have created 3 local functions with ‘cube’: ‘square’, ‘row’, and ‘face’.

‘square’ takes in a single RGB colour and returns a 50 pixel by 50 pixel pygame image that is filled with that colour.

‘row’ takes in a list of 3 RGB tuples, creates an image and blits 3 squares to it in a row, with 10 pixels spacing between them, where the colours of the squares are taken from the list in order. It then returns the created image.

‘face’ takes in a 2D array of RGB tuples as a parameter, and for each list it creates a row. These rows are stacked vertically with 10 pixels spacing. It then returns this created image.

As this is a net design, 4 of the faces are in a line with a fixed y value. Therefore, I have used a loop to place these faces. The loop blits the images returned by the ‘face’ function, using the i iterator to give the correct 2D array from the ‘colour_3d_array’ as a parameter.

The iterator is also used for changing the x position of the images: width/2 centres the images, +10 is used for manually adjusting the position of the image to look more centred, i-2 ensures two faces go to the left of the centre and two go to the right, so the image is fully centred, and \*200 ensures faces aren’t placed on top of each other, as well as adding 30 pixels spacing. The y axes is fixed: height/2 places the images at the centre of the screen, and -2/170 removes half of the height of the faces, as the position given where the top left of the image is placed, not the centre.

The up and down faces were placed without a loop. Whilst a loop could be used, I felt this would unnecessary complicate something that can easily be achieved in a few lines of code. Like in the loop, the ‘face’ function is called and the image it returns blitted. For the x position the same logic as in the loop applies, with the iterator equalling 1 as this lines up the net design. For the y position height/2 centres the image, -170 moves the image up above the row of 4 images, + or – 170/2 accounts for the fact the position is of the top eft of the image, + or – 20 is for spacing between the faces, and + or – 10 is for manual adjustment of the images.

![A screen shot of a computer program Description automatically generated](media/ddc986043b053b15243b737fc23c8c6b.png)

This section allows interactions with the cube and is what must be correct to ensure the cube has the correct logic.

In this section of code, I have created a function to handle rotating each section of the cube. This required lots of iterative testing due to the complicated nature of Rubik’s cube logic, and due to me using a trial and error approach to figuring out how the logic works. The procedure takes in Boolean ‘row_col’, int ‘number’ and Boolean ‘backwards’. ‘row_col’ indicates whether the turn is to be done to a row (True) or column (False). ‘number’ indicates which row/column number needs to be done, 0, 1 or 2 along the face. ‘backwards’ allows for the reverse of a turn to be done.

First, I create a ‘loop’ variable set to one, then change it to three ibackwards is true. Everything in this function following this is in a loop that iterates based on the ‘loop’ variable. This is because a Rubik’s cube works with 90 degree turns, so turning backwards is the same as turning forwards 3 times.

I then create a deep copy of each face. This is done so these new variables can serve as temp variables, allowing me to change each face without risking losing what the original position of the face was. A deep copy was used as it copies by value, instead of reference, which ensures these temp variables are not changed when the actual cube array is changed.

Next, I create a variable n equal to number as this is quicker to type. I did not want to change the parameter name to n as this would be unclear is read at a later date by someone wanting to use the function.

After that, I have an if statement to check if the operation is to be done to a row or a column. In the row section, I update the horizontal section of ‘used_cube’ by changing each face to the one after it. I then check if the rotation was done to the top or bottom row, and rotate the top or bottom face if they were, as this is what happens with a real Rubiks cube. For the column section, I used a loop to move each square one by one. This helps when it comes to reversing the order of the row and the column when the column rotates to/from the back face, which is achieved by the 2-I and the 2-n. It also allows for the row to be iterated. Then, similar to the row rotation, I check if the column being turned if one of the edge ones and rotate the left or right face.

![A screen shot of a computer program Description automatically generated](media/88594c7938a01468afe2f842f9d868f2.png)

In this final section of code, I have the main game loop. I first initialise pygame, then I create a while True loop. This loop will always run, only stopping when it encounters an error from trying to execute a pygame command for a pygame window that has been quit.

The majority of this loop is checking for events – the events list is gotten then looped through, and I check for different types of events. If the event is the quit button being pressed, pygame is quit and the program finishes. Every other event is for rotating the cube.

Then I fill the screen with the colour black to create a black background, then call the ‘cube’ function which will blit the cube net image. Then the display is refreshed so the actual image displayed is updated.

### Testing

### 

| Test No. | What is being tested                   | Description                                                                                                                                | Method                                                                                                                                                                                  | Expected Output                                     | Pass/Fail |
|----------|----------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|-----------|
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
| 2        | Cube turn – vertical, left, up         | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated upwards.    | Execute the turns function with the parameters for the turn. Run the cube display, the display should show the new cube state. The same rotation should be done to a real Rubik’s cube. | The image of both cubes should be exactly the same. | Pass      |
| 3        | Cube turns – vertical, middle, up      | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated upwards.      |                                                                                                                                                                                         |                                                     | Pass      |
| 4        | Cube turns – vertical, right, up       | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated upwards.   |                                                                                                                                                                                         |                                                     | Pass      |
| 5        | Cube turns – vertical, left, down      | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated downwards.  |                                                                                                                                                                                         |                                                     | Pass      |
| 6        | Cube turns – vertical, middle, down    | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated downwards.    |                                                                                                                                                                                         |                                                     | Pass      |
| 7        | Cube turns – vertical, right, down     | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated downwards. |                                                                                                                                                                                         |                                                     | Pass      |
| 8        | Cube turns – horizontal, top, right    | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated right.            |                                                                                                                                                                                         |                                                     | Pass      |
| 9        | Cube turns – horizontal, middle, right | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated right.           |                                                                                                                                                                                         |                                                     | Pass      |
| 10       | Cube turns – horizontal, bottom, right | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated right.            |                                                                                                                                                                                         |                                                     | Pass      |
| 11       | Cube turns – horizontal, top, left     | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated left.             |                                                                                                                                                                                         |                                                     | Fail      |
| 12       | Cube turns – horizontal, middle, left  | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated left.            |                                                                                                                                                                                         |                                                     | Fail      |
| 13       | Cube turns – horizontal, bottom, left  | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated left.             |                                                                                                                                                                                         |                                                     | Fail      |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |
|          |                                        |                                                                                                                                            |                                                                                                                                                                                         |                                                     |           |

### Improvements

11, 12 and 13 should have passed, but did not. I mistakenly used keys y, h, n instead of the keys r, f, v, which are what I chose to use as the keys for those turns. The function itself worked correctly

![](media/56344c296902054e09c639c98bb60759.png) ![A screen shot of a computer program Description automatically generated](media/fa6efa43cba540b725a108319be1ca25.png)

### Program Images

![A screenshot of a computer screen Description automatically generated](media/5c8b7c6881eda58693d6e7794ccca456.png)

![A screenshot of a computer screen Description automatically generated](media/c30214e775cf236f5606efc97ae37866.png)

## Prototype 2

### Development

As the scope of prototype 2 was much greater and more complicated than prototype one, I initially split the code into 4 files: main – which is the file to run, and uses pygame to display the cube and features, and to record user inputs; cube – which manages any interactions with the cube, including getting the image; interface – which handles creating complicated visual elements to be displayed such as text and buttons; validation – which handles validating screen positions and anything I may find that needs validation. However, during development, I realised that I was copying some constants, and passing the same variable repeatedly through all the files, so I created a data file to store these commonly used pieces of data. During this I also realised I had made some mistakes with the format of my docstrings, so I also fixed those, and some were unclear, so I fixed that.

Cube display:

• 3D methods [research](#cube-method-research)

• [Cube class](#PrototypeTwoDisplayClass)

• Cube [object](#PrototypeTwoDisplayObjects) and screen creation

• Display [images](#PrototypeTwoDisplayUsage)

Cube Logic:

• Data [storage](#PrototypeTwoLogicStorage)

• [Turns](#PrototypeTwoLogicTurns)

• [Rotations](#PrototypeTwoLogicRotations)

Scramble:

• [Function](#PrototypeTwoScrambleFunction)

• [Usage](#PrototypeTwoScrambleUsage)

Solver:

• [Storage](#PrototypeTwoSolverStorage) (added to by [Turns](#PrototypeTwoLogicTurns) and [Rotations](#PrototypeTwoLogicRotations))

• [Class](#PrototypeTwoSolverClass)

• [Object](#PrototypeTwoSolverObject)

• [Usage](#PrototypeTwoSolverUsage)

Hint:

• [Function](#PrototypeTwoHintFunction) (of Solver)

• [Usage](#PrototypeTwoHintUsage)

Timer:

• [Class](#PrototypeTwoTimerClass)

• [Object](#PrototypeTwoTimerObject)

• [Automatic start](#PrototypeTwoTimerAutomaticStart)

• [Automatic stop](#PrototypeTwoTimerAutomaticStop)

• [Usage](#PrototypeTwoSolverUsage)

Guide:

• [Class](#PrototypeTwoGuideClass)

• [Object](#PrototypeTwoGuideObject)

• [Usage](#PrototypeTwoGuideUsage)

Validation:

• [Class](#PrototypeTwoValidationClass)

• [Object](#PrototypeTwoValidationObject)

• Usage can be seen throughout [Main](#main)

• [Ignore invalid key presses](#PrototypeTwoValidationIgnoreInvalidKeyPr)

• [Ignore cube interactions when on guide](#PrototypeTwoValidationIgnoreForGuide)

#### Cube method research

The first goal of my protype two – past the fixes specified in review, was to have a 3D Rubik’s cube. To achieve this, I first had to decide of a method of displaying a 3D cube, as I had not decided on an exact method to use during development, although I knew it was likely I would use pygame, I couldn’t be completely confident until I tried coding it to see what worked.

![](media/16c5ccf17dd7abbed9d94aa4467199b2.png)

![A screenshot of a computer Description automatically generated](media/29f50712cfbffdc67ff7051d6b1ceb73.png)

I looked into many options, one of which used matplotlib. I found and this code from to get a look into how it might function, I found I wasn’t happy with the results.

![A screen shot of a computer Description automatically generated](media/d764294919c2e30806330d79b14d1432.png)![A red and green cube on a black background Description automatically generated](media/1dee61fefc9efd976cd6ced37fa29c1d.png)

In the end I did decide to use pygame, using stretched and angles cubes to give the impression of it being 3D, manually drawing them, without using any complicated 3D libraries. As I coded this myself, I was confident in how it worked and therefore comfortable expanding upon it to create a full Rubik’s cube.

#### Main![A screenshot of a computer program Description automatically generated](media/88f4a11bc05e81d53fce92cb4702c706.png)

As I knew I had made mistakes (albeit small ones) when it came to documentation in prototype one, I endeavoured to have perfect documentation this time. As such, the main file (along with every other file) starts with a doc-string. Then, like in prototype one, importing the necessary libraries, although this time I’m also importing my own files. I chose to import all from data as this is the main file, and as such will end up needing most of the data.

I have also allowed the screen window to be resized by the user, however, most of the calculations to place images on the surface are only done once and will be done before the has the chance to change the screen size, resulting in changing screen size making little difference for the user.

I then create 3 objects – one of each cube type – from the imported cube classes from cube file. These are what draw the image of the cube to the screen, at the position specified, when their update method is ran.

The aforementioned positions are validated by being run through the ValidateScreenPositions class, or more specifically, the class’s run function. This ensures that the positions are within the bounds of the screen and a 4k resolution. Every other screen position in the main file is also validated this way.

![A screenshot of a computer program Description automatically generated](media/a15ec10e3d79950bc604d7e2cb67874c.png)

![A screen shot of a computer program Description automatically generated](media/6fd3b96662aadbcb7652ab4af5d34613.png)

Next, I have created a class that manages the buttons for swapping between the different types of cubes that can be displayed (3D, net, guide). As this class only has one purpose and only serves to encapsulate the buttons, it has no constructor, and the two functions are static, meaning that they do the exact same thing regardless of the state of the object they are in.

The buttons are object of the class DisplayOption from the interface file, and they are placed in a list that is a parameter to DisplayBar, which was specifically designed to work with objects of DisplayOption. The buttons are placed in a column in the top left corner of the screen, and this position is validated. The buttons are given the get_image function of their respective cubes and a size of [100, 100], meaning the image they display is what just a shrunk-down version of what will actually be displayed to the screen as the main cube. When a button is hovered, it will be enlarged by 1.5x in each direction, and the cube_bar will account for this and move the images to ensure they do not overlap.

The update function is somewhat unneeded, as running Buttons.update() has the exact same effect as running Buttons.cube_option_bar.update(), however I felt it resulted in cleaner code and helped abstract away unneeded elements.

![](media/21ad7859bff6a29cb74f42d8c4da097b.png)

Then I have defined a variable for whether or not the cube is actively being solve, and 2 for the objects of Solver and Timer respectively.

![A screen shot of a computer Description automatically generated](media/0dfd7f48bb0a3e0eb7dc9735fcc0a292.png)

I then start the game loop. At the start if the game loop I update some key information – mouse_pos and mouse_up, as these are important for the event checks that are about to happen. Mouse up is set to False in case it was being pressed last game loop but isn’t anymore, and it will be one of the first events checked so it can be updated.

I also update the screen size for the validation object in case the user has resized the screen, but as mentioned earlier this has little effect on what and where things are displayed. However, adding this update in now ensures that I don’t forget it if I add more support for resizing the screen at a later date.

I iterate though all the new events, checking for expected inputs. The ‘and …’ portion of line 121 ensures that no cube rotations or turns happen when the cube guide is being displayed, as the cube guide displays the default cube image which isn’t supposed to be changed. I have updated the keys used for left turns so that they now match what is expected. In the portion for the solve key being pressed the timer is deleted as a completion time shouldn’t be awarded for using the solve function. The scramble portion starts the timer as the timer is supposed to start automatically and be as easy to use as possible. The hint feature simply uses the solve function that gets the next move to do, as the hint feature is supposed to just do one move.

![](media/d6e0bdc3cb378649ee7c9d555cda7f4b.png)

In the final part of the game loop, I get and draw all the images to the screen. The if solve_cube section works to do a single move of the solve and wait the calculated amount of time between each move. The else ensures that after each solve the first attribute of solve is reset to True, for the next solve.

The if and elifs on lines 181, 184, and 186 change display_cube to the correct object so that display_cube.update() only has to be written once. The guide portion also writes additional text to the screen. Ideally, this should be apart of the guide_image, but as the classes responsible for the images place the image based on a centre position, adding them would change the position of the cube so it would no longer be centred. As I want to avoid this, I have simply added the text directly to the screen like this.

#### Validation

![](media/8caa02f26a1a42a97437d0b583b56cc7.png)

In a large project, particularly one that will be used by others, error handling is very important of the code, ensuring that any unexpected errors are recorded so that they can be fixed, and so that anyone working with the code knows what went wrong and what to avoid doing. Important sections of code would be within try except statements to handle any errors that do occur.

As my code is relatively simple and static (there is not much that can be changed, so if it works once, it will likely always work), this is far less important for me. However, I wanted to learn more about error handling, and there is nothing to prevent me from using this file in other projects I end up working on, so I decided to do validation . As such, I have created a custom exception for invalid screen positions, which can be raised as an exception, and will document itself in an error file with a timestamp and the position that caused the error, so that if one does occur, I can hopefully identify what caused it and fix it.

![](media/aa8ecbbe6cb6ca1fe629afb71b988386.png)

I’ve also updated the validation function to check if its within the expected screen size, although I kept the 4k resolution checks in case the screen size ends up incorrect. I also changed it to raise the exception instead of printing an error message and quitting the program.

To prevent having the pass the width and height of the screen each time the validation function is run, I made it into a class that stores the width and height of the screen, and created a function to update that information should it change.

#### Cube

![](media/df3acbc07d351ce9b0e34b8164f9705c.png)

I first import all the required libraries and files, including all the colour constants I have denied in the data file.

![A screenshot of a computer program Description automatically generated](media/3389ea5b0cf7992f4c4c459791068266.png)

I then create the cube and the copy, as well as create a moves list that will store all the moves made. This is vital for the Solve feature, as it works by undoing all of the completed moves. And for the hint feature, as that uses the solve function.

![A screen shot of a computer program Description automatically generated](media/880cdde28157775b0405ef305e1d85fa.png)

![A screen shot of a computer program Description automatically generated](media/d32daf4ee619e0a04bc6e2ad786bcfb0.png)

I then create a class for the net design of the cube, so that it can have an update function that will display the cube to the screen at the saved position. The get_image function is very similar to the cube function in prototype one, as it creates the same image. It is a static method as it creates the image based solely on the used_cube variable available in that file. I am able to use the used_cube variable like this as I have no intentions of having any cube states available past the state of the user’s cube and the default image.

![A screen shot of a computer Description automatically generated](media/5f5b6de64c897b9f4f8bb9515e0dd3b4.png)

![A screenshot of a computer program Description automatically generated](media/269fb5f5875a2c05293075826efccbfb.png)

I then create a class for the 3D version of the cube, which inherits the CubeNet class, allowing me to reuse the constructor and update methods. The get image function is polymorphed, meaning that its name stays the same, but it works differently than the get image function in the parent class. In this case I have changed it so that it creates and returns a psudo-3D image, using slanted images to give the impression of a 3D cube.

It works by using subfunctions with subfunctions to break the image down into individual cubes, then slowly constructing it, into rows then a face. The surf.colourkey makes the background of the surface transparent, which is important as these slanted cubes can end up overlapping, and would break the image if the not for the transparency,

![](media/76371510116d2c654d7a60dc5d9891af.png)

![A screen shot of a computer program Description automatically generated](media/1a022393d1cffc0abfa8112e458c8663.png)

![A screenshot of a computer program Description automatically generated](media/6b35ed0c496805140cde78c27897a726.png)![A screen shot of a computer program Description automatically generated](media/48acc8352ed4f82dc01bdf81548757c4.png)

Unfortunately, despite the similarity of the right, front and top images they are not similar enough that using a single function instead could meaningfully decrease the amount of code required.

![A screen shot of a computer Description automatically generated](media/6e142f7440ec27e5fb3ee214feb81a0f.png)

Finally, the 3 functions can be called to create the image.

![A screen shot of a computer program Description automatically generated](media/a96e90c4959b42a7214f39877ed0fe7f.png)

Next, I create the class for the cube guide – an annotated version of the 3D cube which serves as a guide for using the program. This class inherits from Cube3D, again reusing the constructor and update methods. However, whilst I still want to change the get_image function, I also want to be able to use the get_image function from Cube3D. As such, I have used @classmethod instead of @staticmethod. This means that, unlike static methods, it is not completely independent of the class, but it does require the object-specific self, it instead only requires a pointer to the class itself. This allows super() to be used in the function to access methods from the parent class.

I have also added a very basic warning in case the background colour ends up the same colour as the guide arrows, making then impossible to see. Whilst far from a perfect solution, as this is a simple problem, a small error message such as this should be sufficient for anyone to identify the problem should one occur.

![A screenshot of a computer program Description automatically generated](media/46c71a3c4878a40258ef1d2ff2611f59.png)

![](media/342fe036a356b46f1508cc5a752c45bf.png)

![](media/2fdbbc668aeff4017dd263e295e3c7d2.png)

Inside the get_image function I created 3 sub-functions. arrow_top creates an arrow aligned to the top slant of the cube that can display text (to instruct the user on what key press will achieve that rotation), the rotation parameter allows any degree of rotation, buts its intended usage was specifically angle=180 to get an arrow for the downwards rotation. arrow_right is similar to arrow_top, just aligned to the right side of the cube. arrow_rotate has no alignment to the cube, instead creating a large arrow to show the direction of rotation.

![A screen shot of a computer Description automatically generated](media/242ca3506b67c83964ba4e6a733baf38.png)

At the end of the get_image function I first define variables cube_offset_x and cube_offset_y. These are used to help move all the images on the surf whilst maintaining their positions relative to each other. This was important as when I started placing the images I had started with the cube too far to the left, and didn’t have enough space for Y rotation arrow. Thanks to the offset variables I only had to update 2 variables to move everything to the right to make space.

To get the image of the cube, I used the super() function so that I could access Cube3D’s get_image function. I passed True as a parameter as I wanted the guide cube to always show the default image.

Then all the arrows were created and blitted to the surf before it is returned.

![](media/440392b968ae18935b2a427e41cfdf6f.png)

![A computer screen shot of a program Description automatically generated](media/fa8f3f38ad6fb29dc601aab47c8d5253.png)

The turn function is a slightly updated and renamed version of the rotate function from prototype one. The 2 coding changes are the addition of recording moves and changing the iterator of the loop. Apart from that some small changes were made to the docstring and comments.

The addition of recording moves involved adding ignore_moves as a parameter and lines 585-588 to record the moves. Ignore moves allows moves to be undone by the solver without getting readded to the list.

The iterator was changed to \_ from I as \_ is conventionally used as a throwaway variable, and the loop doesn’t need to know the iteration it is on for any reason, which this indicates.

![](media/f6646392eb1d54aced790af316e423a6.png)

The rotate function does a rotation to the cube and like the turn function, it adds the move to the moves list. Rotations in the x or y direction are achieved by turning each row or column once. Rotations in the z axis were far more complicated. Whilst I knew what needed to be done physically to the cube, I couldn’t think of exactly how to that whilst using the 3D array. However, I was confident that whatever the solution was it would involve the rotations of face 1 and 3, and face0=face5, face5=face2, etc. As such, I chose to use a trial-and-error approach until I found something that worked.

![A screenshot of a computer program Description automatically generated](media/ba9fe88c4c79eb9a9a2312a7767ef73d.png)

To scramble the cube whilst ensuring that it was possible to solve, I chose to make many turns, knowing that if the turn function worked correctly it couldn’t result in an impossible position. I used the random library to randomise each turn, and have many turns are made. I arbitrarily chose between 15 and 25 turns, finding this resulted in a sufficiently difficult position. Each move is also added to the moves list so that the solve function can undo them.

![](media/4770ee2ba920f2fa72d12921e888d9f4.png)

For the solve function I created a class, with sleep_time being used in the game loop to ensure each solve takes 5 seconds, assuming there’s no hardware limitations.

![](media/eff039acfd52c43b18fe722a52d5abb4.png)

The solve function itself first checks if the cube is solved as a guard clause. This prevents the solve function from un-solving a cube just so it can completely empty the moves list. Doing this as a guard clause means checking and returning before the main block of code, so the main block isn’t reached. Guard clauses can be treated as if all the following code is in an else block, but without the need for indentation.

The solve function calculates the time to sleep for that move, before returning pop.move(), which is what will undo the move.

![A computer screen shot of a computer code Description automatically generated](media/c359ca60872a250149792a5bb0db1240.png)

The check_solve function checks whether all squares on a face match the centre square, as this is the case for a solved cube and if this is true for every face, then it must be a solved cube. The not_solved variable will be updated to True if any one of these checks fails, as then the cube can’t be solved. The return includes a not as I want the output to be True if the cube is solved.

![A screenshot of a computer program Description automatically generated](media/24d8e2f3dcb25da3c6482d4ff4535548.png)

The pop_move function is static as it only uses the move list. It gets the last done move from the move list and undoes it, before returning if the moves list is empty or not. It is possible the cube may be solved even when the moves list still has moves in it, but this is checked for in the solve() function, which is its primary usage and where this issue is most likely to occur.

The moves list should ideally be stored in a class, requiring moves to be added by a function, to ensure that all moves added are stored in the correct format, however due to the small scale of this project I felt I could safely access the moves list directly and just ensure I was using the correct format every time I did.

![](media/451e6e95d3132c7438c8eaece778479e.png)

![](media/11df48f79f32a9a63a6a043fed0c59c5.png)

The timer class manages recording the time taken for a solve so far, and in total. It also creates an image with the time taken to display to the user. If the time taken is less than a minute the image displays the time taken rounded to the millisecond, otherwise it displays the time taken in mutes and seconds.

The minutes are obtained by dividing by 60, and this value gets rounded down when it is converted to python. The seconds are obtained using modulus 60, and this also gets converted to an integer, as I did not feel milliseconds were important after the time taken exceeds a minute.

#### Interface

![A screenshot of a computer Description automatically generated](media/27df915f51e423a11a15d9ff33bed030.png)

![A screenshot of a computer program Description automatically generated](media/55ef1ba14d5731a6bb327c61acbd7c78.png)

The DisplayOption class creates a button that enlarges when hovered over. It takes a function as a parameter to get an image to display. This allows it to have an updating image. The get_image function gets the image and scales it to the size of the button based on self.size. The background is also made transparent.

![A screen shot of a computer program Description automatically generated](media/e1b6ca80409095c9fe0b2e9131c7bccf.png)

The update function will display the button to the screen. It includes an offset as when many buttons are next to each other, and one is enlarged the rest need to move or there will be overlapping. The last size is used as the user will see the image with its last size, not the image about to be gotten, and thus that is the size of the button they expect.

The button checks if it is being hovered by checking if the mouse position collides with its image. If it is, its checked if the mouse button has been pressed. If it has the button action is done. If not, self.size is stored in a temp variable, before self.size is updated to the enlarged size, and then get_image is called. As get image uses self.size, it will return the enlarged image. Self.size is then returned to its original size by using the temp value.

![](media/6a2350369896b7e3df5083386a7d303a.png)

DisplayBar was created to help manage DisplayOption objects. It allows for a bar of vertical or horizontal buttons to be created. With the objects stored sequentially in order from the edge of what they can touch, a loop can be used to check if an object is being hovered and offset all the following buttons by the change that object’s image size, preventing overlap. This also updates all of the DisplayOptions.

![A computer screen shot of a program Description automatically generated](media/4b69dd604fc9fa4a97f176341d3fb376.png)

The text function returns the image created by rendering the text. The surface’s Rect is returned by .render but it is not needed so I assign it to the throwaway variable. I also run .convert_alpha() on the image as this optimises the image for faster blitting to the screen.

#### Data

![A screen shot of a computer Description automatically generated](media/7deb18dab8ea21a3b4403ec60eb25c28.png)

The data file holds key data used by every file, so that I can be easily accessed and updated as needed.

### Testing

### 

| Test No. | What is being tested                   | Description                                                                                                                                                                        | Method                                                                                                                                                                                  | Expected Output                                                                                                          | Pass/Fail |
|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|-----------|
| 1        | 3D cube algorithm                      | There should be an image algorithm that either returns a pygame.Surface containing an image of the cube, or display the cube to the screen.                                        | Blit the image returned by the function to the screen or call the function, inside the main game loop.  Repeat whilst making changes to used_cube.                                      | An image should be displayed and it should match used_cube.                                                              | Pass      |
| 2        | Cube turn – vertical, left, up         | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated upwards.                                            | Execute the turns function with the parameters for the turn. Run the cube display, the display should show the new cube state. The same rotation should be done to a real Rubik’s cube. | The image of both cubes should be exactly the same.                                                                      | Pass      |
| 3        | Cube turns – vertical, middle, up      | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated upwards.                                              |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 4        | Cube turns – vertical, right, up       | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated upwards.                                           |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 5        | Cube turns – vertical, left, down      | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated downwards.                                          |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 6        | Cube turns – vertical, middle, down    | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated downwards.                                            |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 7        | Cube turns – vertical, right, down     | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated downwards.                                         |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 8        | Cube turns – horizontal, top, right    | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated right.                                                    |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 9        | Cube turns – horizontal, middle, right | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated right.                                                   |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 10       | Cube turns – horizontal, bottom, right | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated right.                                                    |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 11       | Cube turns – horizontal, top, left     | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated left.                                                     |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 12       | Cube turns – horizontal, middle, left  | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated left.                                                    |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 13       | Cube turns – horizontal, bottom, left  | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated left.                                                     |                                                                                                                                                                                         |                                                                                                                          | Pass      |
| 14       | Scramble                               | The scramble function should randomly position the individual squares whilst still ensuring that the cube is solvable.                                                             | Add a delay between each move in the scramble function. Run the scramble function and follow along with a real Rubik’s cube.                                                            | Each move done by the scrambler should be possible on the real Rubik’s cube.                                             | Pass      |
| 15       | Solver - solving                       | The solve function should solve the cube, showing the user each step, ensuring that each move is possible and not simply changing the used_cube to fit as needed.                  | Manually scramble the cube, doing each move to a real Rubik’s cube as well. Run the solver and follow the moves on the Real Rubik’s cube.                                               | Each move done by the solver should be possible on the real Rubik’s cue and at the end the cube should be solved.        | Fail      |
| 16       | Solver – stop solving                  | If used_cube reaches a solved state, the solver should stop solving, regardless of if there something such as a moves list indicates there are more moves to do to solve the cube. | Manually scramble the cube, ensuring that you return to a solved state at least once then scramble from there. Run the solver.                                                          | The solver should stop when it reaches the first solved state.                                                           | Pass      |
| 17       | Check solved                           | There should be a function to check if a cube state is solved or not.                                                                                                              | Test the function using multiple different cube states, some of which are manually or automatically scrambled.                                                                          | The outputs should match the given cube state.                                                                           | Pass      |
| 18       | Hints                                  | The hint function should complete one move towards the solve. It must only be one move and it must help solve the cube.                                                            | Scramble the cube then run the runt the hint function. Note the move that it makes. Undo that move and then run the solver (test 15 must have passed).                                  | Only one move should be completed by the hint function. The move should match the one done by the solver.                | Pass      |
| 19       | Timer – time elapsed                   | The timer should correctly record the amount of timer that has passed since it started                                                                                             | Start the timer. Wait for 10 seconds (counted via a trusted, real, timer). Print the time elapsed.  Repeat a few times with various amounts of time waited.                             | The trusted timer and the timer being tested should have a matching (or very similar, to account for human error) times. | Pass      |
| 20       | Timer – auto start                     | The timer should automatically start upon scramble.                                                                                                                                | Scramble the cube. Solve the cube. Scramble the cube, use hint function. Scramble the cube. Use the solve function. Scramble the cube.  Monitor the time elapsed during this.           | Each time the cube is scrambled the timer should start,                                                                  | Pass      |
| 21       | Timer – auto stop                      | The timer should automatically stop upon being solved.                                                                                                                             |                                                                                                                                                                                         | Upon being solved and when the solver is used, the timer should stop. The timer should not stop if these do not occur.   | Fail      |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
| 27       | Guide algorithm                        | The should either be a function that returns a pygame.Surface or a procedure that draws the image to the screen.   The image should show how to use the cube.                      | Either blit the pygame.Surface to the screen or call the procedure inside a game loop.                                                                                                  | An image should be displayed.                                                                                            | Pass      |
| 28       | Guide algorithm – prevent moves        | The cube image should only display the default cube and as such it should not allow cube interactions to happen when the guide is being displayed.                                 | When displaying the cube, try the following: turns, rotations, scrambling and solving.                                                                                                  | None of the functions should work. The cube should remain unchanged.                                                     | Pass      |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |
|          |                                        |                                                                                                                                                                                    |                                                                                                                                                                                         |                                                                                                                          |           |

### Improvements

Test 15 – The solve function results in a key error when rotations are in the move list.

This was due to a small spelling mistake in ‘rotation’ in line 773 which resulted in rotations being treated as turns.

![](media/22a5f62ada208688337f97a95acb54cd.png)

This was easily solved by simply fixing the spelling mistake.

![A screen shot of a computer program Description automatically generated](media/70e1c78c0c2b6abfee12dcc223437252.png)

Test 21 – If the scramble key is pressed before the solver ends, the timer will start whilst the solver continues to solve the cube. This was solved by making the solver stop when the scramble key (which also starts the timer) is pressed.

![A screen shot of a computer program Description automatically generated](media/b3d328103d412debd449aa36eae7e5e7.png)

### Program Images

![](media/9652d952780c038f52a8752d7b4b989f.png)

![A colorful squares on a grey background Description automatically generated](media/5648df05996c483523c9abea108a52a2.png)

![A graphic of a rubik's cube Description automatically generated](media/025b00f4d8f6f3b1f1d8afd1dd8d1b4d.png)

![A colorful cube with many squares Description automatically generated](media/8bda2bda407930eb47c60cb1733e90ab.png)

![A screenshot of a game Description automatically generated](media/2b93588d1c189ff42ebf74dc74c11fdc.png)

## Prototype 3

### Development

Cube display:

• [Class](#PrototypeThreeDisplayClass)

• [Object](#PrototypeThreeDisplayObjects)

• [Image](#PrototypeThreeDisplayImage)

Cube logic:

• [Data storage](#PrototypeThreeLogicStorage)

• [Turns](#PrototypeThreeLogicTurns)

• [Rotations](#PrototypeThreeLogicRotations)

Scramble:

• [Function](#PrototypeThreeScrambleFunction)

• [Usage](#PrototypeThreeScrambleUsage)

Solver:

• Moves [class](#PrototypeThreeSolverStorage)

• Solver [class](#PrototypeThreeSolverClass)

• [Usage](#PrototypeThreeSolverUsage)

Hint:

• [Function](#PrototypeThreeHintFunction)

• [Usage](#PrototypeThreeHintUsage)

Timer:

• [Class](#PrototypeThreeTimerClass)

• [Object](#PrototypeThreeTimerObject)

• Automatic [start](#PrototypeThreeTimerAutomaticStart)

• Automatic [stop](#PrototypeThreeTimerAutomaticStop)

Leaderboard:

• [Class](#PrototypeThreeLeaderboardClass)

• [Object](#PrototypeThreeLeaderboardObjects)

• [Image](#PrototypeThreeLeaderboardImage)

Login:

• [Usage](#PrototypeThreeLogin)

Guide:

• [Class](#PrototypeThreeGuideClass)

• [Object](#PrototypeThreeGuideObject)

• [Usage](#PrototypeThreeGuideUsage)

Save:

• File [storage](#PrototypeThreeSaveStorage)

• Manager [class](#PrototypeThreeSaveClassManager)

• User [class](#PrototypeThreeSaveClassUser)

• [Automatic](#PrototypeThreeSaveAutomatic)

History:

• [Data](#PrototypeThreeHistoryData)

• [Class](#PrototypeThreeHistoryClass)

• [Object](#PrototypeThreeHistoryObjects)

• [Image](#PrototypeThreeHistoryImage)

Validation:

• [Class](#PrototypeThreeValidationClass)

• [Object](#PrototypeThreeValidationObject)

• Usage throughout [Main](#main-1)

• [Ignore invalid key presses](#PrototypeThreeValidationIgnoreInvalidKey)

• [Ignore cube interactions when on guide](#PrototypeThreeValidationIgnoreForGuide)

#### Main

![](media/3d1172f55ab54cb6b916a8126e8b5c1d.png)

The additional files have been imported and the new display elements – history and leaderboard – have been added to the display section. Game_data has been imported as well as had all imported from it, as to change variables in other files you must use file.variable = …, as from file import variable gets the variables value, instead of a pointer to it.

![A screenshot of a computer program Description automatically generated](media/bc0e1c489c99c2b01013c5d91874ac8b.png)

![A screenshot of a computer program Description automatically generated](media/3affe7cf81753bfeb5769e288dbee552.png)

![A screen shot of a computer Description automatically generated](media/5948a40e84d6ee99b9a4d9877af0d67c.png)

![A computer screen shot of a computer program Description automatically generated](media/0ae04944ab40c37b6ef56e4ea3a5c5f5.png)

The buttons class is largely the same, just with display_history and display_leaderboard getting their buttons added.

![A screenshot of a computer program Description automatically generated](media/9ed7a1a2a0bf3b590e72bd20570bdc69.png)

The load function is designed to be called by the login_window, which give it the user’s username. The save functions in the user data file will use this to load their data. This function then checks if the timer or solver are supposed to be running and updates their objects variables to start them in a way that makes it seem as if they never stopped.

The login function is then called. This starts the login window, which checks the user’s username and password before calling the load function.

![A screen shot of a computer Description automatically generated](media/82774e4597aa6e9ba76f102ece686da4.png)

The first section of the events portion in nearly the same, with only the one event being added for mouse scrolling. This allows the game history image to be scrolled.

The quit section has been updated to include sys.exit(), which will close the program, as it was previously stopping due to an error occurring when trying to run a pygame function when pygame had been quit.

![](media/1e49bc0ca1055f6e91ce526ec834311a.png)

The second section has statements added to update the information in game_data when key events happen. It will also add completed games to the user’s game history.

![A screen shot of a computer Description automatically generated](media/12c9536f6619f909034a804a8b5b7972.png)

![A screen shot of a computer program Description automatically generated](media/899a5a6910a055d051e3f75c38e0b916.png)

The game loop is largely the same as well, with features added to update the user’s game history on a completed solve, display the new history and leaderboard screens, and to run the save function every 5 seconds.

#### Validation

This file is unchanged from prototype 2.

![A computer screen shot of a program Description automatically generated](media/e8c3ae0a1ab61dab028e8b53ddef9557.png)

![](media/e68d78bff636f3648a9c27576258b7c7.png)

#### Cube

The cube file has been split across 3 files: cube, features, and game_data.

The 3 cube classes that display an image remain in the cube file, along with the turn and rotations functions. The code for these is largely the same, with only small adjustments made as to account for data structures such as the moves list being moved into game_data.

![](media/6399552d3f99190e3caf0218eb5423a3.png)

![A screenshot of a computer program Description automatically generated](media/ba13b64bc3f36551a46d085f21ecab85.png)

![A screenshot of a computer program Description automatically generated](media/2fa21300227995e432d4f294c318fce5.png)

![A screenshot of a computer program Description automatically generated](media/bd768d95f94d9bfa899628326d7adf26.png)

![A screenshot of a computer program Description automatically generated](media/6183570782cd200fbf9aa248078a2be1.png)

![A screenshot of a computer program Description automatically generated](media/5e547eeae35785b6c48a61f23297c021.png)

![](media/414553f095059a75f29adb4dd715e554.png)

![A screenshot of a computer program Description automatically generated](media/5a5e17bd307c35a9e244c2775847c8d0.png)![A computer screen shot of a program code Description automatically generated](media/8c1038f9378d19bb24d54e38aa61c731.png)![A screenshot of a computer program Description automatically generated](media/d9760933851b4aeca800e13d2f3a5719.png)![A screen shot of a computer program Description automatically generated](media/e1fe237f32f9c66931d4d057aab82cd8.png)![A screenshot of a computer program Description automatically generated](media/e4aa913a8285e9a8af0fcf1eaf60ab07.png)![A screenshot of a computer program Description automatically generated](media/a795da99e7e70f99276830b03ac17c87.png)

![A screenshot of a computer program Description automatically generated](media/26748141e47db2d4cb6bbc692cc8c5b9.png) ![A screen shot of a computer program Description automatically generated](media/f900ca2d7156b38aab6c2199fb0ee34f.png) ![A screenshot of a computer program Description automatically generated](media/e58e02383abb8b975af82c94e9c105b5.png)

#### Features

The features move from the old cube file to this file remain largely the same, with only small changes to them to due to not being in the same file as the data structures. However, there are two new classes at the end of the file for displaying the game history and leaderboard.

![](media/295247c679f3e378b45e96ce36a657e1.png)![A screenshot of a computer program Description automatically generated](media/5c1f04f85c829e9f305520cb6b373934.png)![A screen shot of a computer program Description automatically generated](media/e3c3d56c4913ee415df725c41a4d1bbd.png)![A screenshot of a computer program Description automatically generated](media/5b3e81c3cedef039f00b36057cd8afcf.png)![A screen shot of a computer program Description automatically generated](media/efe9aa149fcc2e2fb5ea2f7e33421206.png) ![A screenshot of a computer program Description automatically generated](media/8e59025452b986b450aa50d1928811f0.png)

The display history class manages getting the user’s game history and displaying it to the screen. The image it creates is scrollable.

The format_history function creates a 2D array, where the outer index is games, and the inner index is specific information. Only certain information has been taken from the user’s game history, and it all has been converted to a format the user will understand (e.g. time into hours, minutes, seconds) and then to a string that can be rendered.

I would have liked to make the time displayed include milliseconds, however the time library I had been using for times did not support this and I unfortunately did not have time to figure a way to implement this.

![A screen shot of a computer Description automatically generated](media/6fb7b28df18e43fc74b398dfc97bf328.png)

The get_image function uses the formatted list to create the image. It creates an image for each game that is just a rendered string and uses the get_height function and a variable to ensure the surf created is big enough, as the number of images being drawn to it is variable.

As the images are being created before the surf is, they are stored in a list, then iteratively blitted to the surf once it is created.

![](media/5601c25b07a7f8372a169f96aa5d05ff.png)

The update function doesn’t used validation, despite the fact it has a changing and thus non-validated screen position it blits to, as it is intended that the surf will be blitted offscreen if scrolled far enough.

The scroll function updates the y offset so that the image can be scrolled.

![A screenshot of a computer program Description automatically generated](media/f4504c4db2b9097f0e6e9a9c79a4b4e5.png)

The leaderboard class manages creating and displaying the leaderboard. It contains another class that holds a single entry to the leaderboard, and that class also conforms to the specifications in the tools.File class that is being used to store the top ten scores, which includes having a unique, if meaningless id. Ideally the id would have some significance however its possible for multiple entries to be from the same user, or have the same time taken, or have the same number of moves done, so I had to create a separate variable for the id.

The entries are sorted after being obtained as the tools.File will store them according to their id, not their times.

![](media/c10445408a415c880fa2ffa46231bf16.png)

The update list function manages checking new scores against the existing ones and adding or replacing scores if necessary. If the leaderboard isn’t full the solve is guaranteed to be added. When this is done the entry is given the id equal to the length entries list as this id cannot exist yet unless an entry is deleted without another being added, which shouldn’t happen.

If the slowest entry is quicker than or equal to the solve being checked the function exits as the entries aren’t going to changed. This is \<= as if two solves have taken the same amount of time I believe the solve done first should be the one to stay, if there not going to both be on the leaderboard. As this is checking against the slowest entry, only one of them can be on the leaderboard.

The final elif could have been an else, but I used an elif to make it clear when this will execute. It creates a new entry to replace the slowest one. It uses the same id as entry its replacing to ensure the list doesn’t end up with duplicate ids.

![A computer screen shot of a program Description automatically generated](media/84049e1de1fd8574ff1a36ac94906cc7.png)

![](media/b08818e4969ad677a66d7b71058d75ce.png)

To sort the list I had originally created the above insertion sort style code, however I then realised the built-in sort function could be passed a keyword argument ‘key’ which would allow me to use it to sort by the time attribute of the entry classes. As this is more efficient than my function I used this instead, although I placed it within my sort function so I did not have to replace any of the self.sort calls.

![A screen shot of a computer program Description automatically generated](media/2d383a4d34b72aeabe19f128eedce290.png)

The get_image function works similar to the DisplayHistory’s get_image method, but it isn’t scrollable, and values used are different.

#### Game Data

The game_data file exists to hold and manage global data.

![A screen shot of a computer program Description automatically generated](media/86b40271d401b27a2eb6f1c14bde7f64.png)

![A screenshot of a computer Description automatically generated](media/b439fca5d53b1f744e39c6f2fdc7867b.png) ![A screen shot of a computer Description automatically generated](media/e48f0639345398248b5ff3c3c002c709.png)

I decided to make a class for the move stack so I could ensure that any moves added do have the correct structure. As such, the docstring specifies the two acceptable dictionary format and checks the given parameter matches one of these, and raises an error if it doesn’t.

![](media/97ad2152fbe82f0e3b279acca982b907.png)

The stack also contains some basic stack functions.

![A screenshot of a computer program Description automatically generated](media/c85e12e5203bd6289126621a61eb6fe3.png)

#### Interface

The only changes to the interface file were minor docstring edits on lines 37, 73, 75, 165, 166.

![](media/feabe1552bbe9ef415188f4462527d3e.png)![](media/2a2683ea4845247740ed4ef342dc54a7.png)![A screenshot of a computer program Description automatically generated](media/d20241d781e6553576a304c44813da07.png)![A screenshot of a computer program Description automatically generated](media/d3dd55bc4ab8f92d499e8eda49d92a22.png)

![A computer screen shot of a program code Description automatically generated](media/89bb46479b1795ba4146af78b2107850.png)

#### User Data

The user data file was created to manage storing a user’s data, including creating a list of their game history.

![A screenshot of a computer program Description automatically generated](media/9a419506d2c4265e44270fc05be798c8.png)

As the .__dict_\_ method is used the names, order, and amount of attributes cannot be changed without risking breaking things. This is not a good thing to do but it does greatly simplify the add function later on.

![](media/75ce943be41507083eac4931a743ea2b.png)

The aforementioned add function – it sets it attributes to the value of their respective variable in game_data, effectively updating them. Then they are added to the history list. Instead of manually creating the list of data to add to the history_list, I have used self.__dict__.values() to obtain the values of the attributes, then converted it to a list. This includes the history_list attribute itself, so that is remove by restricting the list to everything but its last value (history_list) with [:-1]. This means even changing the order of attributes would break things but, as I am the only one working on this project, and as adding or removing any variables would cause problems anyway unless every user’s history is wiped, I do not think it is too severe an issue.

![A screen shot of a computer program Description automatically generated](media/c4643844ee5302c9160bae52b74b4a6d.png)![](media/ec9ffbf5f6d1eee968fce90892430202.png)

The user class is designed to work with the tools.File class which also uses the \__dict_\_ method that history does, so it works very similarly.

![A screenshot of a computer program Description automatically generated](media/71ae14da8ae953929fbb64a71fc34b98.png)

The manager class serves to encapsulate the functions used for saving and loading data. It handles using the tools.File class as well as the User class to load and save data. The load function uses a try except statement to check if a user exists and create an account for them if they don’t.

#### Tools

When developing the save feature, I realised I needed a way to save users to a file, and be able to retrieve that specific user. As I have had to do something similar on multiple projects, I decided to make a general solution that can work for saving to any file. I also decided to put this in a tools file, something I am going to continue developing so I can use it on any project where it may help.

![A computer screen with text and images Description automatically generated](media/4628ddde25cd993747e14c5897dd3eb8.png)

I created a custom exception to raise in case an object being searched for is not found. The exception gives the identifier that couldn’t be found, and the name of the file being looked in.

![](media/2b4183f65915e5ecd11cce55180b92a7.png)

As this is a general purpose class, I have provided many methods. Some of these may cause issues if used together, as they update the data in different ways and thus could end up overwriting each other, so I have noted in the class’s documentation to not do that.

If the file that is too be used for saving doesn’t already exist, the class will handle creating it.

![A screenshot of a computer program Description automatically generated](media/950fd3057cd938465d5172b9c148824b.png)

As the file stores classes where the first attribute is the identifier, the identifier can be obtained by getting the data associated with the first key in the classes dictionary.

To recreate the classes from the stored dictionaries, each line of the file is iterated through. Each line is read as a whole as a string and evaluated, which converts it back into a dictionary. The dictionary is then given to the class to be reconstructed as a set of keyword arguments, where the keys of the dictionary are the keywords. As the dictionary is in order of the class’s arguments this works the same as \*(eval(obj).values()), which would get the values of the keys of the dictionary and pass them as many arguments – instead of keywords and arguments.

I originally found the out about the eval function from [this](https://stackoverflow.com/a/988249) stack overflow comment, and when I then went looking into how I could use the dictionary I found [this](https://stackoverflow.com/a/334666).

![](media/6baa7a231b9d580921ad62f70a4a33d2.png)

![A screen shot of a computer code Description automatically generated](media/2da83f6936250728a6311a4fb38ef2de.png)

I had originally used a merge sort to sort the list based on its identifier, but after learning I could use the .sort method with a key whilst developing the leaderboard, I switched it to using that instead.

![A screenshot of a computer program Description automatically generated](media/56e4d39733a7518d11409156c402c11d.png)

I used a binary search for the search function as it is easy to code and efficient. The pos variable tracks the what position the start of the current sub-list is in the main self.list, as this means when a position is returned it is the useful and meaningful position of the searched item in the accessible self.list.

![](media/3d9c81940fef7f9ea82ab53a8ef13f20.png)

The save function works by ensuring the list is sorted then overwriting the file with it, where it writes the dictionary of the class in the list, one dictionary/class per line.

![A screenshot of a computer program Description automatically generated](media/35f8f421253d639f4064a032c058c8b0.png)

![A screen shot of a computer program Description automatically generated](media/b7285ebad7e7a60c0bbc33e2da8f8300.png)

As I do not have tests for this file, I did some smalls tests at the end of the file, using line 229 to ensure the tests do not execute when the file is imported.

### Testing

| 29 | Save – to file | The save algorithm should be able to save all the key data to a text file. | Use the save function with a variety of different key information, including extreme test data such as the timer being at 0.0 seconds and the cube already being solved.  In each case attempt loading the program with this saved data, ensuring it is loaded as current game data. | The save file should be updated to include the key data for the user. | Fail |
|----|----------------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------|------|

![](media/96c7aa28bb53453eff90d8f32ad35686.png)

The first issue I encountered, before even being able to use my tests, is a user not being found when the Manager.save function is run. This shouldn’t be an issue as the Manager.load function should have run before the save function ever could, and it was designed to create a user if the didn’t, exist. After investigating, I found that the problem was as simple as me never actually adding the created user to the File class.

![A screen shot of a computer Description automatically generated](media/7f85ecf04cd08d3ae3ceddf4c6a54c55.png)

Fixed by

![A screen shot of a computer Description automatically generated](media/7a78ad12a689a134f9b59f6f61443a27.png)

| Test No. | What is being tested                   | Description                                                                                                                                                                                          | Method                                                                                                                                                                                                                                                                               | Expected Output                                                                                                                             | Pass/Fail |
|----------|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| 1        | 3D cube algorithm                      | There should be an image algorithm that either returns a pygame.Surface containing an image of the cube, or display the cube to the screen.                                                          | Blit the image returned by the function to the screen or call the function, inside the main game loop.  Repeat whilst making changes to used_cube.                                                                                                                                   | An image should be displayed and it should match used_cube.                                                                                 | Pass      |
| 2        | Cube turn – vertical, left, up         | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated upwards.                                                              | Execute the turns function with the parameters for the turn. Run the cube display, the display should show the new cube state. The same rotation should be done to a real Rubik’s cube.                                                                                              | The image of both cubes should be exactly the same.                                                                                         | Pass      |
| 3        | Cube turns – vertical, middle, up      | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated upwards.                                                                |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 4        | Cube turns – vertical, right, up       | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated upwards.                                                             |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 5        | Cube turns – vertical, left, down      | Executing the turns function with the correct parameters for the given turn should result in the leftmost column being rotated downwards.                                                            |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 6        | Cube turns – vertical, middle, down    | Executing the turns function with the correct parameters for the given turn should result in the middle column being rotated downwards.                                                              |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 7        | Cube turns – vertical, right, down     | Executing the turns function with the correct parameters for the given turn should result in the rightmost column being rotated downwards.                                                           |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 8        | Cube turns – horizontal, top, right    | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated right.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 9        | Cube turns – horizontal, middle, right | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated right.                                                                     |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 10       | Cube turns – horizontal, bottom, right | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated right.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 11       | Cube turns – horizontal, top, left     | Executing the turns function with the correct parameters for the given turn should result in the upper row being rotated left.                                                                       |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 12       | Cube turns – horizontal, middle, left  | Executing the turns function with the correct parameters for the given turn should result in the middle row being rotated left.                                                                      |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 13       | Cube turns – horizontal, bottom, left  | Executing the turns function with the correct parameters for the given turn should result in the lower row being rotated left.                                                                       |                                                                                                                                                                                                                                                                                      |                                                                                                                                             | Pass      |
| 14       | Scramble                               | The scramble function should randomly position the individual squares whilst still ensuring that the cube is solvable.                                                                               | Add a delay between each move in the scramble function. Run the scramble function and follow along with a real Rubik’s cube.                                                                                                                                                         | Each move done by the scrambler should be possible on the real Rubik’s cube.                                                                | Pass      |
| 15       | Solver - solving                       | The solve function should solve the cube, showing the user each step, ensuring that each move is possible and not simply changing the used_cube to fit as needed.                                    | Manually scramble the cube, doing each move to a real Rubik’s cube as well. Run the solver and follow the moves on the Real Rubik’s cube.                                                                                                                                            | Each move done by the solver should be possible on the real Rubik’s cue and at the end the cube should be solved.                           | Fail      |
| 16       | Solver – stop solving                  | If used_cube reaches a solved state, the solver should stop solving, regardless of if there something such as a moves list indicates there are more moves to do to solve the cube.                   | Manually scramble the cube, ensuring that you return to a solved state at least once then scramble from there. Run the solver.                                                                                                                                                       | The solver should stop when it reaches the first solved state.                                                                              | Pass      |
| 17       | Check solved                           | There should be a function to check if a cube state is solved or not.                                                                                                                                | Test the function using multiple different cube states, some of which are manually or automatically scrambled.                                                                                                                                                                       | The outputs should match the given cube state.                                                                                              | Pass      |
| 18       | Hints                                  | The hint function should complete one move towards the solve. It must only be one move and it must help solve the cube.                                                                              | Scramble the cube then run the runt the hint function. Note the move that it makes. Undo that move and then run the solver (test 15 must have passed).                                                                                                                               | Only one move should be completed by the hint function. The move should match the one done by the solver.                                   | Fail      |
| 19       | Timer – time elapsed                   | The timer should correctly record the amount of timer that has passed since it started                                                                                                               | Start the timer. Wait for 10 seconds (counted via a trusted, real, timer). Print the time elapsed.  Repeat a few times with various amounts of time waited.                                                                                                                          | The trusted timer and the timer being tested should have a matching (or very similar, to account for human error) times.                    | Pass      |
| 20       | Timer – auto start                     | The timer should automatically start upon scramble.                                                                                                                                                  | Scramble the cube. Solve the cube. Scramble the cube, use hint function. Scramble the cube. Use the solve function. Scramble the cube.  Monitor the time elapsed during this.                                                                                                        | Each time the cube is scrambled the timer should start,                                                                                     | Pass      |
| 21       | Timer – auto stop                      | The timer should automatically stop upon being solved.                                                                                                                                               |                                                                                                                                                                                                                                                                                      | Upon being solved and when the solver is used, the timer should stop. The timer should not stop if these do not occur.                      | Fail      |
| 22       | Leaderboard – Eligibility check        | Each entry should be checked to see if they are faster than the slowest time on the leaderboard, to see if they have made it onto the leaderboard.                                                   | Submit a completion with a slower completion time than the slowest. Submit a completion with a faster time than the slowest. Submit a completion time identical to the slowest.                                                                                                      | Only the completion with the faster time should be considered for updating the leaderboard.                                                 | Pass      |
| 23       | Leaderboard – add entry                | If the leaderboard isn’t full any completion should be added to the leaderboard. If the leaderboard if full and entry is eligible, the new entry should replace the slowest time on the leaderboard. | Add an entry when the leaderboard is empty. Add an entry when the leaderboard is half full. Add an entry when the leaderboard is full.                                                                                                                                               | The first two entries should be automatically added to the leaderboard. The last entry should replace the slowest entry on the leaderboard. | Pass      |
| 24       | Leaderboard – sort leaderboard         | When a new completion is added to the leaderboard, the leaderboard needs to be sorted to ensure that completion ends up in the correct position. The list should be ordered by ascending times.      | Sort the leaderboard when it is already in order. Sort the leaderboard when it is in descending order. Sort the leaderboard when it is randomised. Sort the leaderboard when 2 identical times exist.                                                                                | Each leaderboard should end up sorted. Manually check this.                                                                                 | Pass      |
| 25       | Leaderboard – save times               | The ordered list of leaderboard times should be able to be saved to a text file so that they are kept even when the program ends.                                                                    | Save the leaderboard when it is empty. Save the leaderboard when it has no completions. Save the leaderboard when it is half full. Save the leaderboard when it is full.  In each case close the program and start it again, attempting to load these saves.                         | In each case the text file should be updated with the leaderboard.                                                                          | Pass      |
| 26       | Leaderboard – load saved times         | The saved leaderboard times need to be able to be loaded so they can be displayed and be checked against for any new records.                                                                        |                                                                                                                                                                                                                                                                                      | In each case the leaderboard should be updated to match the text file.                                                                      | Pass      |
| 27       | Guide algorithm                        | The should either be a function that returns a pygame.Surface or a procedure that draws the image to the screen.   The image should show how to use the cube.                                        | Either blit the pygame.Surface to the screen or call the procedure inside a game loop.                                                                                                                                                                                               | An image should be displayed.                                                                                                               | Pass      |
| 28       | Guide algorithm – prevent moves        | The cube image should only display the default cube and as such it should not allow cube interactions to happen when the guide is being displayed.                                                   | When displaying the cube, try the following: turns, rotations, scrambling and solving.                                                                                                                                                                                               | None of the functions should work. The cube should remain unchanged.                                                                        | Pass      |
| 30       | Save – load form file                  | The save algorithm should be manage loading the data from the text file and updating game values so it is as if the saved state has been achieved in the current session.                            | Use the save function with a variety of different key information, including extreme test data such as the timer being at 0.0 seconds and the cube already being solved.  In each case attempt loading the program with this saved data, ensuring it is loaded as current game data. | The save file should be updated to include the key data for the user.                                                                       | Fail      |
| 31       | Save – autosave                        | The save function should automatically run periodically.                                                                                                                                             | Start a game and make some changes to the cube. Then wait the amount of time set between saves. Once this time has passed closer and reopen the program.                                                                                                                             | The cube should be in the same state as it was when the program was closed,                                                                 | Pass      |
| 32       | Game history                           | When a solve is complete, either by the solve function being used, the scrambler being used, or the cube being solved, the data about that solve should be saved to a list of solves.                | Finish a solve using the solver, scrambler, and by solving manually.                                                                                                                                                                                                                 | These three solves should be added to game history list.                                                                                    | Pass      |

### Improvements

Tests 15 and 18 – Both the solver and hint feature work if the scramble function is used once, and then the cube solved. However, if the scramble feature is used more than once the solver and hint feature seems to have a limit for how much of the cube they can solve.

![](media/12a4fb9dab1ec464c9a0a8393196deda.png)

Both these features share the function Solver.pop_move, so I investigated that function. I could find no errors with it, so I knew it had something to do with game_data.moves stack. As the problem occurred when the scramble function was called, I checked when the function was called in the game loop.

![A screen shot of a computer Description automatically generated](media/0e9b89d4e976d314d6800d7b1f6682db.png)

The problem was then immediately obvious, the moves list was being cleared each time the scramble function was called, and the move_count set to 0, but the moves themselves where still done and needed to be know so the solver can undo them.

I chose to fix this by making the scramble function reset the cube to default before scrambling it, which ensures this error won’t occur again.

Original:

![](media/56917cb33834f8e27327952c5711e38d.png)

![A computer screen shot of a program code Description automatically generated](media/ff7e392aa138158809c805f8a900017a.png)

Fixed:

![A screen shot of a computer code Description automatically generated](media/63a193a5324cc7221b15a9dc0886c391.png)

![A computer screen shot of a code Description automatically generated](media/4cc5dbe7d5970be7301e4cd6210ab3e0.png)

Tests 21 and 30 – The issue was that the timer function sometimes stopped automatically, and sometimes it continued when the cube was solved. I quickly determined that the Solver.check_solved() function was the problem, as it returned False even when the cube was solved. However, when checking the function, everything appeared to be in order.

However, in the saves_data.txt file, the cube state had an interesting anomaly. Some of the colours were being saved as tuples, whilst some were saved as lists. The save files was also being broken and has ‘array’ for it for some reason. This broken file format had been preventing me from loading saves, however I had simply been deleting the save file (so a new one was created, which worked) before starting the program each time, as I was focusing on the this (and previous) errors, waiting to fix the loading error until I reached the save test.

![](media/20fb567951662d5a94a7eea98a0b1266.png)

Unfortunately, I still had little idea what could be causing this, so I decided to test each possible turn one by one. I found only edge turns resulted in this, but middle turns did not. This did help, as I knew the main coding difference between middle turns and edge turns was that edge turns involved using numpy.rot90 on the face the edge touched. After checking, I found that numpy.rot90 did return an array like I expected, but instead an ndarray. I fixed this by using .tolist(), a method of ndarrays which returns them as a normal list. I made sure to include this for the z axis rotation as well.

Original:

![](media/28cba0fdfca710a0b31e421f53e97260.png)

![](media/21dc1e400ebd6017554716d3aead8cf9.png)

Fixed:

![A screen shot of a computer program Description automatically generated](media/2baf8ea15cb21ee2f7d19b386c603f9e.png)

![](media/9ce47eb2e2d8416a9b67580eb1809537.png)

This fixed my saving issue, but still prevented check_sorted from working, as some tuples were still becoming lists. I could have created a small function to check to convert the RGB lists back into tuples, but this function would have had to be called every time check_solved was run, and any other function that relied on the colours being a consistent data type, so I instead decided to get rid of the tuples completely and just use lists. To do this I just converted the colours in game_data from tuples to lists.

Original Fixed

![](media/589417893b42cc2ebdf04c74e8565f54.png) ![A screen shot of a computer Description automatically generated](media/02f8fe9aeaad37e3c18ef392f839783e.png)

This finally fixed the problem.

### Program Images

![A screenshot of a login screen Description automatically generated](media/94dfb862c2173150c4818ec92dfe08f1.png)

![A screenshot of a login box Description automatically generated](media/9a0a34ae789cd6805dc01a9464b8c387.png)

![A screenshot of a login box Description automatically generated](media/60360051ae7828b483e4065d736316f1.png)

![A screenshot of a login box Description automatically generated](media/904f1775a5e8b0404f03eef75d52dacd.png) ![A screenshot of a login box Description automatically generated](media/cc3a4481348fd2c1ea35738f02638877.png) ![A screenshot of a login box Description automatically generated](media/7aa1f933b85eed8a518de557f4f52564.png) ![A screenshot of a login box Description automatically generated](media/c6471813adb8a5a1eb2f62e43a8b5fd1.png) ![A screenshot of a login box Description automatically generated](media/b9b6823d534eba5fd175196ba7469192.png)![A screenshot of a computer Description automatically generated](media/daf472ab4b0a2906fe174c213c69f9e9.png) ![A screenshot of a computer Description automatically generated](media/7ab56f1eac7a145913a7aa1ea40a8724.png) ![A screenshot of a computer Description automatically generated](media/fc88219022985e83c90ce2cbb82911c8.png) ![A screenshot of a computer Description automatically generated](media/5ed5af7742ae9cff34d303413becec29.png) ![A screenshot of a computer Description automatically generated](media/8f2e08632cf3eb00c84cb0a635778b02.png) ![A screenshot of a computer screen Description automatically generated](media/f76cfcce0665bc0d105ef000396851fd.png) ![](media/ade31e24fcedeec7c44e4ee6eb5b4d8f.png) ![A screenshot of a video game Description automatically generated](media/757e5f5ff86b50a7f21d2ef50a79e35f.png) ![A screenshot of a video game Description automatically generated](media/d06cf84382d5cb960231e4b1fd7474a7.png) ![A cube with different colored squares Description automatically generated](media/4eaa8e244d0c8ceb3d7031a254173931.png) ![A cube with different colored squares Description automatically generated](media/a5dc41b4fc0fab210315afe473f0fb64.png) ![A cube with different colored squares Description automatically generated](media/1298991a13febac7a41e26aa39082952.png) ![A colorful cube on a grey background Description automatically generated](media/473f3bd7a9d4ebc1e8e3a297f9493b25.png) ![A screenshot of a game Description automatically generated](media/dda923ca0c2ce43e9e572df6ce478864.png) ![A screenshot of a video game Description automatically generated](media/e1c2c8d1b02df557e45b50916d3c6aa7.png) ![A grey background with black text Description automatically generated](media/33ce0b5c532a928ec0bd23b9f2e4465b.png) ![A grey background with black text Description automatically generated](media/63b85e72462c619ad06b6af533666ef5.png)

# Evaluation

## Post-development testing

| Stakeholder name: |                                                                                                                 |             |                    |
|-------------------|-----------------------------------------------------------------------------------------------------------------|-------------|--------------------|
| Test no.          | Question                                                                                                        | Answer type | Stakeholder Answer |
| 33                | Is there a representation of a 3D cube?                                                                         | Yes or No   |                    |
| 34                | How professional does the 3D cube look?                                                                         | 1 to 10     |                    |
| 35                | To your knowledge, is every move that’s possible on a real Rubik’s cube possible on the program’s Rubik’s cube? | Yes or No   |                    |
| 35                | To your knowledge, is every move possible on the program possible on a real Rubik’s cube?                       |             |                    |
| 37                | How well do the cube controls meet the description: simple and intuitive?                                       | 1 to 10     |                    |
| 38                | How well do he program controls meet the description: simple and intuitive?                                     |             |                    |
| 39                | Is there a scramble function?                                                                                   | Yes or No   |                    |
| 40                | Is there a solve function?                                                                                      |             |                    |
| 41                | How well does the solve function show each move done (in regards to you being able to understand it)?           | 1 to 10     |                    |
| 42                | Is there a hint function that shows you the next move to make?                                                  | Yes or No   |                    |
| 43                | Is there a timer to track how long solves take?                                                                 |             |                    |
| 44                | Does the timer start automatically?                                                                             |             |                    |
| 45                | Does the timer stop automatically?                                                                              |             |                    |
| 46                | Is there a leaderboard?                                                                                         |             |                    |
| 47                | Does the leaderboard show the ten quickest solves in ascending order?                                           |             |                    |
| 48                | Does each leaderboard entry display: the username, the time taken, the moves taken?                             |             |                    |
| 49                | Is there a login system?                                                                                        |             |                    |
| 50                | How straightforward to use is the login system?                                                                 | 1 to 10     |                    |
| 51                | Is your user and game data loaded when you log in?                                                              | Yes or No   |                    |
| 52                | Does the save function run automatically?                                                                       |             |                    |
| 53                | Is there a guide to use the program?                                                                            |             |                    |
| 54                | How clear and concise is the guide?                                                                             | 1 to 10     |                    |
| 55                | Is there a function to see your game history?                                                                   | Yes or No   |                    |
| 56                | How easy does the game history function make it to see how you have progressed?                                 | 1 to 10     |                    |
